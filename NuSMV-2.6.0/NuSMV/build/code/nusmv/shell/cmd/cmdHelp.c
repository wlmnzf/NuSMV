/* ---------------------------------------------------------------------------

  This file is part of the ``cmd'' package of NuSMV version 2.
  Copyright (C) 2015 by FBK-irst.

  NuSMV version 2 is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  NuSMV version 2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.

  For more information on NuSMV see <http://nusmv.fbk.eu>
  or email to <nusmv-users@fbk.eu>.
  Please report bugs to <nusmv-users@fbk.eu>.

  To contact the NuSMV development board, email to <nusmv@fbk.eu>.

-----------------------------------------------------------------------------*/

/*!
  \author Samuele Gallerani
  \brief The module contains an array with the couple command_name and
  command_description

  This source file contains an empty array, with cmake it is populated
  with the actual shell commands and relative description.
*/


//#include "Int.h"

#include <stdio.h>
#include <stdlib.h>

#include "nusmv/shell/cmd/cmdCmdInt.h"
#include "nusmv/shell/cmd/cmdCmd.h"
#include "nusmv/core/utils/assoc.h"


/*---------------------------------------------------------------------------*/
/* Structure declarations                                                    */
/*---------------------------------------------------------------------------*/

/* this is computed by scripts/create_help.py -c */
command_item command_help[] = {
{"hrc_write_model", "COMMAND= hrc_write_model   Writes the hrc structure from root node\n"
"to a given SMV file \n"
"usage: hrc_write_model [-h] | [-o \"filename\"] [-d]\n"
" Writes\n"
"the currently loaded SMV model stored in hrc structure in the\n"
"specified file. If no file is specified the standard output is used.\n"
"\n"
"    Command Options:\n"
"\n"
"    -o \"filename\"\n"
"\n"
"    Attempts to write the SMV model in \"filename\".\n"
"\n"
"    -d\n"
"\n"
"    Renames modules appending \"_hrc\" the the original module name.\n"
"\n"
""},
{"hrc_dump_model", "COMMAND= hrc_dump_model   Writes the hrc structure from root node to\n"
"a given SMV file \n"
"usage: hrc_dump_model [-h] | [-o \"filename\"] [-d]\n"
" Writes\n"
"the currently loaded SMV model stored in hrc structure in the\n"
"specified file. If no file is specified the standard output is used.\n"
"\n"
"    Command Options:\n"
"\n"
"    -f \"format\"\n"
"\n"
"    Dumps in the given format (debug, smv or xml).\n"
"\n"
"    -o \"filename\"\n"
"\n"
"    Dumps output to \"filename\"\n"
"\n"
"    -d\n"
"\n"
"    Renames every module name appending the suffix \"_hrc\"\n"
"\n"
"    -i\n"
"\n"
"    Disable indentation.\n"
"\n"
""},
{"pick_state", "COMMAND= pick_state   Picks a state from the set of initial states\n"
"\n"
"usage: pick_state [-h] [-v] [-r | -i [-a]] [-c \"constraints\" | -s\n"
"trace.state]\n"
" Chooses an element from the set of initial states, and\n"
"makes it the current state (replacing the old one). The chosen state is\n"
"stored as the first state of a new trace ready to be lengthened by steps\n"
"states by the simulate command. The state can be chosen according to\n"
"different policies which can be specified via command line options.\n"
"By default the state is chosen in a deterministic way.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints out chosen state (all state variables,\n"
"    otherwise it prints out only the label t.1 of the state chosen,\n"
"    where t is the number of the new trace, that is the number of traces\n"
"    so far generated plus one).\n"
"\n"
"    -r\n"
"\n"
"    Randomly picks a state from the set of initial states.\n"
"\n"
"    -i\n"
"\n"
"    Enables the user to interactively pick up an initial state. The\n"
"    user is requested to choose a state from a list of possible items\n"
"    (every item in the list doesn't show state variables unchanged\n"
"    with respect to a previous item). If the number of possible states\n"
"    is too high, then the user has to specify some further constraints\n"
"    as \"simple expression\".\n"
"\n"
"    -a\n"
"\n"
"    Displays all state variables (changed and unchanged with\n"
"    respect to a previous item) in an interactive picking. This\n"
"    option works only if the -i options has been specified.\n"
"\n"
"    -c \"constraints\"\n"
"\n"
"    Uses constraints to restrict the set of initial states in which\n"
"    the state has to be picked.\n"
"\n"
"    -s trace.state\n"
"\n"
"    Picks state from trace.state label. A new simulation trace will\n"
"    be created by copying prefix of the source trace up to specified\n"
"    state.\n"
"\n"
""},
{"simulate", "COMMAND= simulate   Performs a simulation from the current selected\n"
"state \n"
"usage: simulate [-h] [-p | -v] [-r | -i [-a]] [[-c \"constraints\"]\n"
"| [-t \"constraints\"] ] [-k steps] \n"
" Generates a sequence of at most\n"
"steps states (representing a possible execution of the model),\n"
"starting from the current state. The current state must be set via the\n"
"pick_state or goto_state commands.\n"
"\n"
"It is possible to run the simulation in three ways (according to\n"
"different command line policies): deterministic (the default\n"
"mode), random and interactive.\n"
"\n"
"The resulting sequence is stored in a trace indexed with an integer\n"
"number taking into account the total number of traces stored in the\n"
"system. There is a different behavior in the way traces are built,\n"
"according to how current state is set: current state is always put at\n"
"the beginning of a new trace (so it will contain at most steps + 1 states)\n"
"except when it is the last state of an existent old trace. In this case\n"
"the old trace is lengthened by at most steps states.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -p\n"
"\n"
"    Prints current generated trace (only those variables whose\n"
"    value changed from the previous state).\n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints current generated trace (changed and\n"
"    unchanged state variables).\n"
"\n"
"    -r\n"
"\n"
"    Picks a state from a set of possible future states in a random way.\n"
"\n"
"    -i\n"
"\n"
"    Enables the user to interactively choose every state of the\n"
"    trace, step by step. If the number of possible states is too high,\n"
"    then the user has to specify some constraints as simple\n"
"    expression. These constraints are used only for a single\n"
"    simulation step and are forgotten in the following ones. They are\n"
"    to be intended in an opposite way with respect to those\n"
"    constraints eventually entered with the pick_state command, or\n"
"    during an interactive simulation session (when the number of\n"
"    future states to be displayed is too high), that are local only to a\n"
"    single step of the simulation and are forgotten in the next one.\n"
"\n"
"    -a\n"
"\n"
"    Displays all the state variables (changed and unchanged) during\n"
"    every step of an interactive session. This option works only if\n"
"    the -i option has been specified.\n"
"\n"
"    -c \"constraints\"\n"
"\n"
"    Performs a simulation in which computation is restricted to\n"
"    states satisfying those constraints. The desired sequence of\n"
"    states could not exist if such constraints were too strong or it\n"
"    may happen that at some point of the simulation a future state\n"
"    satisfying those constraints doesn't exist: in that case a trace\n"
"    with a number of states less than steps trace is obtained. The\n"
"    expression cannot contain next operators, and is automatically\n"
"    shifted by one state in order to constraint only the next steps\n"
"\n"
"    -t \"constraints\"\n"
"\n"
"    Performs a simulation in which computation is restricted to\n"
"    states satisfying those constraints. The desired sequence of\n"
"    states could not exist if such constraints were too strong or it\n"
"    may happen that at some point of the simulation a future state\n"
"    satisfying those constraints doesn't exist: in that case a trace\n"
"    with a number of states less than steps trace is obtained. The\n"
"    expression can contain next operators, and is NOT automatically\n"
"    shifted by one state as done with option -c\n"
"\n"
"    -k steps\n"
"\n"
"    Maximum length of the path according to the constraints. The\n"
"    length of a trace could contain less than steps states: this is the\n"
"    case in which simulation stops in an intermediate step because it\n"
"    may not exist any future state satisfying those constraints.\n"
"\n"
""},
{"goto_state", "COMMAND= goto_state   Goes to a given state of a trace\n"
"\n"
"usage: goto_state [-h] state\n"
" Makes state the current state. This\n"
"command is used to navigate alongs traces produced by NuSMV. During\n"
"the navigation, there is a current state, and the current trace is the\n"
"trace the current state belongs to. Command options:\n"
"\n"
"    \n"
"\n"
"    state:\n"
"\n"
"    The state of a trace (trace.state) to be picked.\n"
"\n"
""},
{"print_current_state", "COMMAND= print_current_state   Prints out the current state\n"
"\n"
"usage: print_current_state [-h] [-v]\n"
" Prints the name of the current state if\n"
"defined.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -v\n"
"\n"
"    Prints the value of all the state variables of the current state.\n"
"\n"
""},
{"read_model", "COMMAND= read_model   Reads a NuSMV file into NuSMV.\n"
"\n"
"usage: read_model [-h] [-i model-file]\n"
" Reads a NuSMV file. If the -i\n"
"option is not specified, it reads from the file specified in the\n"
"environment variable input_file.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -i model-file\n"
"\n"
"    Sets the environment variable input_file to model-file, and\n"
"    reads the model from the specified file.\n"
"\n"
""},
{"optional", "COMMAND= optional   optional \n"
"usage: optional optional\n"
" optional"},
{"optional", "COMMAND= optional   optional \n"
"usage: optional optional\n"
" optional"},
{"show_traces", "COMMAND= show_traces   Shows the traces generated in a NuSMV session\n"
"\n"
"usage: show_traces [ [-h] [-v] [-m | -o output-file] [-A] -t | [-d] -a |\n"
"trace_number[.from_state[:[to_state]]] ]\n"
" Shows the traces\n"
"currently stored in system memory, if any. By default it shows the last\n"
"generated trace, if any. A trace number can be specified optionally\n"
"followed by a slice denoting the steps top be shown. Negative numbers\n"
"can be used to denote steps in a right-to-left fashion. (i.e. -1\n"
"denotes last step, -2 is the previous and so forth.)\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints traces content (all state variables,\n"
"    otherwise it prints out only those variables that have changed\n"
"    their value from previous state).\n"
"\n"
"    -t\n"
"\n"
"    Prints only the total number of currently stored traces.\n"
"\n"
"    -a\n"
"\n"
"    Prints all the currently stored traces.\n"
"\n"
"    -A\n"
"\n"
"    Prints traces in an anonimized form.\n"
"\n"
"    -d\n"
"\n"
"    Disables DEFINEs printout in traces\n"
"\n"
"    -p trace plugin\n"
"\n"
"    Uses the specified trace plugin to explain the trace.\n"
"\n"
"    -m\n"
"\n"
"    Pipes the output through the program specified by the PAGER shell\n"
"    variable if defined, else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command to output-file\n"
"\n"
"    trace_number\n"
"\n"
"    The (ordinal) identifier number of the trace to be printed.\n"
"\n"
"    from_state\n"
"\n"
"    Denotes left end of the trace slice to be printed.\n"
"\n"
"    to_state\n"
"\n"
"    Denotes right end of the trace slice to be printed.\n"
"\n"
""},
{"show_plugins", "COMMAND= show_plugins   Lists out all the available plugins inside\n"
"the system. In addition, it prints [D] in front of the default plugin.\n"
"\n"
"usage: show_plugins [ [-h] [-n plugin_index| -a]] CommandDescription [\n"
"Sets the default plugin to print traces.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the usage of the command.\n"
"\n"
"    -n plugin_index\n"
"\n"
"    Prints the description message of the plugin at specified index\n"
"    only.\n"
"\n"
"    -a\n"
"\n"
"    Prints all the available plugins with their description.\n"
"\n"
"]\n"
"*****************************************************************************[EXTRACT_DOC_NOTE:\n"
"* /] \n"
" Sets the default plugin to print traces.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the usage of the command.\n"
"\n"
"    -n plugin_index\n"
"\n"
"    Prints the description message of the plugin at specified index\n"
"    only.\n"
"\n"
"    -a\n"
"\n"
"    Prints all the available plugins with their description.\n"
"\n"
""},
{"read_trace", "COMMAND= read_trace   Reads the trace from the specified file into\n"
"the memory \n"
"usage: read_trace  [-h] | [-i filename] | [-u] [-s] filename\n"
"\n"
"Reads a trace from a specified XML file into the memory.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the usage of the command.\n"
"\n"
"    -i filename\n"
"\n"
"    Specifies the name of the xml trace file to read (deprecated).\n"
"\n"
"    -u\n"
"\n"
"    Turns 'undefined symbol' error in a warning.\n"
"\n"
"    -s\n"
"\n"
"    Turns 'wrong section' error in a warning.\n"
"\n"
"    filename\n"
"\n"
"    Specifies the name of the xml trace file to read\n"
"\n"
""},
{"execute_traces", "COMMAND= execute_traces   Executes complete traces on the model FSM\n"
"\n"
"usage: execute_traces [-h] [-v] [-m | -o output-file] -e engine [-a |\n"
"trace_number]\n"
" Executes traces stored in the Trace Manager. If no\n"
"trace is specified, last registered trace is executed. Traces must be\n"
"complete in order to perform execution.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints traces execution steps\n"
"\n"
"    -a\n"
"\n"
"    Prints all the currently stored traces.\n"
"\n"
"    -m\n"
"\n"
"    Pipes the output through the program specified by the PAGER shell\n"
"    variable if defined, else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command to output-file\n"
"\n"
"    -e executor\n"
"\n"
"    Selects an executor for trace re-execution.\n"
"\n"
"    trace_number\n"
"\n"
"    The (ordinal) identifier number of the trace to be printed.\n"
"\n"
""},
{"execute_partial_traces", "COMMAND= execute_partial_traces   Executes partial traces on the\n"
"model FSM \n"
"usage: execute_partial_traces [-h] [-v] [-r] [-m | -o output-file] -e\n"
"engine [-a | trace_number]\n"
" Executes traces stored in the Trace\n"
"Manager. If no trace is specified, last registered trace is executed.\n"
"Traces are not required to be complete. Upon succesful termination, a\n"
"new complete trace is registered in the Trace Manager.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints traces execution steps.\n"
"\n"
"    -a\n"
"\n"
"    Executes all the currently stored traces.\n"
"\n"
"    -r\n"
"\n"
"    Performs restart on complete states (deprecated).\n"
"\n"
"    -m\n"
"\n"
"    Pipes the output through the program specified by the PAGER shell\n"
"    variable if defined, else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command to output-file\n"
"\n"
"    -e engine\n"
"\n"
"    Selects an engine for trace re-execution. It must be one of 'bdd',\n"
"    'sat'.\n"
"\n"
"    trace_number\n"
"\n"
"    The (ordinal) identifier number of the trace to be printed.\n"
"\n"
""},
{"process_model", "COMMAND= process_model   Performs the batch steps and then returns\n"
"control to the interactive shell. \n"
"usage: process_model [-h] [-f] [-r] [-i\n"
"model-file] [-m Method]\n"
" Reads the model, compiles it into BDD and\n"
"performs the model checking of all the specification contained in it.\n"
"If the environment variable forward_search has been set before, then\n"
"the set of reachable states is computed. If the option -r is specified,\n"
"the reordering of variables is performed accordingly. This command\n"
"simulates the batch behavior of NuSMV and then returns the control to\n"
"the interactive shell.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -f\n"
"\n"
"    Forces model construction even when COI is enabled.\n"
"\n"
"    -r\n"
"\n"
"    Performs a variable ordering at the end of the computation, and\n"
"    dumps the variable ordering as the command line option -reorder\n"
"    does.\n"
"\n"
"    -i model-file\n"
"\n"
"    Sets the environment variable input_file to file model-file,\n"
"    and reads the model from file model-file.\n"
"\n"
"    -m Method\n"
"\n"
"    Sets the environment variable partition_method to Method and\n"
"    uses it as partitioning method.\n"
"\n"
""},
{"flatten_hierarchy", "COMMAND= flatten_hierarchy   Flattens the hierarchy of modules\n"
"\n"
"usage: flatten_hierarchy [-h] [-d]\n"
" This command is responsible of the\n"
"instantiation of modules and processes. The instantiation is\n"
"performed by substituting the actual parameters for the formal\n"
"parameters, and then by prefixing the result via the instance name.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -d\n"
"\n"
"    Delays the construction of vars constraints until needed\n"
"\n"
""},
{"show_vars", "COMMAND= show_vars   Shows model's symbolic variables and their\n"
"values \n"
"usage: show_vars [-h] [-s] [-f] [-i] [-v] [-t|-V] [-m | -o\n"
"output-file]\n"
" Prints symbolic input, frozen and state variables of\n"
"the model with their range of values (as defined in the input file).\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -s\n"
"\n"
"    Prints state variables.\n"
"\n"
"    -f\n"
"\n"
"    Prints frozen variables.\n"
"\n"
"    -i\n"
"\n"
"    Prints input variables.\n"
"\n"
"    -t\n"
"\n"
"    Prints only the number of variables (among selected kinds),\n"
"    grouped by type. Incompatible with -V.\n"
"\n"
"    -V\n"
"\n"
"    Prints only the list of variables with their types (among\n"
"    selected kinds), and no other summary information.\n"
"    Incompatible with -t.\n"
"\n"
"    -D\n"
"\n"
"    Prints only the list of defines. Incompatible with -V.\n"
"\n"
"    -v\n"
"\n"
"    Prints verbosely. With this option, all scalar variable values\n"
"    are printed\n"
"\n"
"    -m\n"
"\n"
"    Pipes the output to the program specified by the PAGER shell\n"
"    variable if defined, else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command to output-file\n"
"\n"
"\n"
"\n"
"By default, if no type specifiers (-s, -f, -i) are used, all variables\n"
"type will be printed. When using one or more type specifiers (e.g. -s),\n"
"only variables belonging to selected types will be printed."},
{"encode_variables", "COMMAND= encode_variables   Builds the BDD variables necessary to\n"
"compile the model into BDD. \n"
"usage: encode_variables [-h] [-i order-file]\n"
"\n"
"Generates the boolean BDD variables and the ADD needed to encode\n"
"propositionally the (symbolic) variables declared in the model.\n"
"\n"
"The variables are created as default in the order in which they appear\n"
"in a depth first traversal of the hierarchy.\n"
"\n"
"The input order file can be partial and can contain variables not\n"
"declared in the model. Variables not declared in the model are simply\n"
"discarded. Variables declared in the model which are not listed in the\n"
"ordering input file will be created and appended at the end of the given\n"
"ordering list, according to the default ordering.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -i order-file\n"
"\n"
"    Sets the environment variable input_order_file to order-file,\n"
"    and reads the variable ordering to be used from file order-file.\n"
"    This can be combined with the write_order command. The variable\n"
"    ordering is written to a file, which can be inspected and\n"
"    reordered by the user, and then read back in.\n"
"\n"
""},
{"build_model", "COMMAND= build_model   Compiles the flattened hierarchy into BDD\n"
"\n"
"usage: build_model [-h] [-f] [-m Method]\n"
" Compiles the flattened\n"
"hierarchy into BDD (initial states, invariants, and transition\n"
"relation) using the method specified in the environment variable\n"
"partition_method for building the transition relation.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m Method\n"
"\n"
"    Sets the environment variable partition_method to the value\n"
"    Method, and then builds the transition relation. Available\n"
"    methods are Monolithic, Threshold and Iwls95CP.\n"
"\n"
"    -f\n"
"\n"
"    Forces model construction. By default, only one partition\n"
"    method is allowed. This option allows to overcome this default,\n"
"    and to build the transition relation with different\n"
"    partitioning methods.\n"
"\n"
""},
{"build_flat_model", "COMMAND= build_flat_model   Compiles the flattened hierarchy into\n"
"SEXP \n"
"usage: build_flat_model [-h]\n"
" Compiles the flattened hierarchy into\n"
"SEXP (initial states, invariants, and transition relation).\n"
"\n"
""},
{"build_boolean_model", "COMMAND= build_boolean_model   Compiles the flattened hierarchy\n"
"into boolean SEXP \n"
"usage: build_boolean_model [-h] [-f]\n"
" Compiles the flattened\n"
"hierarchy into boolean SEXP (initial states, invariants, and\n"
"transition relation).\n"
"\n"
""},
{"write_order", "COMMAND= write_order   Writes variable order to file.\n"
"\n"
"usage: write_order [-h] [-b] [(-o | -f) order-file]\n"
" Writes the current\n"
"order of BDD variables in the file specified via the -o option. If no\n"
"option is specified the environment variable output_order_file\n"
"will be considered. If the variable output_order_file is unset (or\n"
"set to an empty value) then standard output will be used. The option -b\n"
"forces the dumped variable ordering to contain only boolean\n"
"variables. All the scalar variables will be substituted by those\n"
"variables bits that encode them. The variables bits will occur within\n"
"the dumped variable ordering depending on the position they have\n"
"within the system when the command is executed.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -b\n"
"\n"
"    Dumps bits of scalar variables instead of the single scalar\n"
"    variables. When specified, this option temporary overloads the\n"
"    current value of the system variable write_order_dumps_bits.\n"
"\n"
"    -o order-file\n"
"\n"
"    Sets the environment variable output_order_file to order-file\n"
"    and then dumps the ordering list into that file.\n"
"\n"
"    -f order-file\n"
"\n"
"    Alias for -o option. Supplied for backward compatibility.\n"
"\n"
""},
{"print_fsm_stats", "COMMAND= print_fsm_stats   Prints out information about the fsm and\n"
"clustering. \n"
"usage: print_fsm_stats [-h] | [-m] | [-p] | [-o output-file]\n"
"\n"
"This command prints out information regarding the fsm and each\n"
"cluster. In particular for each cluster it prints out the cluster\n"
"number, the size of the cluster (in BDD nodes), the variables\n"
"occurring in it, the size of the cube that has to be quantified out\n"
"relative to the cluster and the variables to be quantified out.\n"
"\n"
"Also the command can print all the normalized predicates the FMS\n"
"consists of. A normalized predicate is a boolean expression which\n"
"does not have other boolean sub-expressions. For example,\n"
"expression (b<0 ? a/b : 0) = c is normalized into (b<0 ? a/b=c : 0=c) which\n"
"has 3 normalized predicates inside: b<0, a/b=c, 0=c. Command\n"
"options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command through the program\n"
"    specified by the PAGER shell variable if defined, or through the\n"
"    UNIX utility \"more\".\n"
"\n"
"    -p\n"
"\n"
"    Prints out the normalized predicates the FSM consists of.\n"
"\n"
"    -o output-file\n"
"\n"
"    Redirects the generated output to the file output-file.\n"
"\n"
""},
{"go", "COMMAND= go   Initializes the system for the verification.\n"
"\n"
"usage: go [-h][-f]\n"
" This command initializes the system for\n"
"verification. It is equivalent to the command sequence read_model,\n"
"flatten_hierarchy, build_flat_model, encode_variables,\n"
"build_model.\n"
"\n"
"If some commands have already been executed, then only the remaining\n"
"ones will be invoked.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -f\n"
"\n"
"    Forces the model contruction.\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the command usage.\n"
"\n"
"    \n"
"\n"
""},
{"go_bmc", "COMMAND= go_bmc   Initializes the system for the BMC verification.\n"
"\n"
"usage: go_bmc [-h] | [-f]\n"
" This command initializes the system for\n"
"verification. It is equivalent to the command sequence read_model,\n"
"flatten_hierarchy, encode_variables, build_boolean_model,\n"
"bmc_setup. If some commands have already been executed, then only the\n"
"remaining ones will be invoked.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -f\n"
"\n"
"    Forces the model construction.\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the command usage.\n"
"\n"
"    \n"
"\n"
""},
{"get_internal_status", "COMMAND= get_internal_status   Returns the internal status of\n"
"    the system. \n"
"usage: get_internal_status [-h]\n"
" Prints out the internal status\n"
"    of the system. i.e.\n"
"\n"
"    - -1 : read_model has not yet been executed or an error occurred\n"
"    during its execution.\n"
"\n"
"    \n"
"\n"
"    - 0 : flatten_hierarchy has not yet been executed or an error\n"
"    occurred during its execution.\n"
"\n"
"    \n"
"\n"
"    - 1 : encode_variables has not yet been executed or an error\n"
"    occurred during its execution.\n"
"\n"
"    \n"
"\n"
"    - 2 : build_model has not yet been executed or an error occurred\n"
"    during its execution.\n"
"\n"
"    \n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the command usage.\n"
"\n"
"    \n"
"\n"
""},
{"write_flat_model", "COMMAND= write_flat_model   Writes a flat model of a given SMV file\n"
"\n"
"usage: write_flat_model [-h] [-o filename] [-A] [-m]\n"
" Processes are\n"
"eliminated and a corresponding equivalent model is printed out. If no\n"
"file is specified, the file specified with the environment variable\n"
"output_flatten_model_file is used if any, otherwise standard\n"
"output is used as output.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -o filename\n"
"\n"
"    Attempts to write the flat SMV model in filename.\n"
"\n"
"    -A\n"
"\n"
"    Write the model using variables and defines rewriting to make it\n"
"    anonimized.\n"
"\n"
"    -m\n"
"\n"
"    Disable printing of key map when writing anonimized model\n"
"\n"
""},
{"write_flat_model_udg", "COMMAND= write_flat_model_udg   Writes a flat model of a given SMV\n"
"file in uDraw format \n"
"usage: write_flat_model_udg [-h] [-o filename]\n"
" Processes\n"
"are eliminated and a corresponding equivalent model is printed out.\n"
"If no file is specified, the file specified with the environment\n"
"variable output_flatten_model_file is used if any, otherwise\n"
"standard output is used as output.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -o filename\n"
"\n"
"    Attempts to write the flat SMV model in filename.\n"
"\n"
""},
{"write_boolean_model", "COMMAND= write_boolean_model   Writes a flattened and booleanized\n"
"model of a given SMV file \n"
"usage: write_boolean_model [-h] [-o filename]\n"
" Writes\n"
"the currently loaded SMV model in the specified file, after having\n"
"flattened and booleanized it. Processes are eliminated and a\n"
"corresponding equivalent model is printed out. If no file is\n"
"specified, the file specified via the environment variable\n"
"output_boolean_model_file is used if any, otherwise standard\n"
"output is used.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -o filename\n"
"\n"
"    Attempts to write the flat and boolean SMV model in filename.\n"
"\n"
"** New in 2.4.0 and later ** Scalar variables are dumped as DEFINEs\n"
"whose body is their boolean encoding. This allows the user to still\n"
"express and see parts of the generated boolean model in terms of the\n"
"original model's scalar variables names and values, and still\n"
"keeping the generated model purely boolean. Also, symbolic\n"
"constants are dumped within a CONSTANTS statement to declare the\n"
"values of the original scalar variables' for future reading of the\n"
"generated file."},
{"write_coi_model", "COMMAND= write_coi_model   Writes a flat model of SMV file,\n"
"restricted to the COI of the model properties \n"
"usage: write_coi_model [-h] [-o\n"
"filename] [-n | -p | -P ] | [-c] | [-l] | [-i] | [-s] | [-q] | [-p expr] | [-C] |\n"
"[-g]\n"
" Writes the currently loaded SMV model in the specified file,\n"
"after having flattened it. If a property is specified, the dumped\n"
"model is the result of applying the COI over that property. otherwise,\n"
"a restricted SMV model is dumped for each property in the property\n"
"database. Processes are eliminated and a corresponding equivalent\n"
"model is printed out. If no file is specified, stderr is used for output\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -o filename\n"
"\n"
"    Attempts to write the flat and boolean SMV model in filename.\n"
"\n"
"    -c\n"
"\n"
"    Dumps COI model for all CTL properties\n"
"\n"
"    -l\n"
"\n"
"    Dumps COI model for all LTL properties\n"
"\n"
"    -i\n"
"\n"
"    Dumps COI model for all INVAR properties\n"
"\n"
"    -s\n"
"\n"
"    Dumps COI model for all PSL properties\n"
"\n"
"    -q\n"
"\n"
"    Dumps COI model for all COMPUTE properties\n"
"\n"
"    -p expr\n"
"\n"
"    Applies COI for the given expression \"expr\"\n"
"\n"
"    -n idx\n"
"\n"
"    Applies COI for property stored at index \"idx\"\n"
"\n"
"    -P name\n"
"\n"
"    Applies COI for property named \"name\" idx\n"
"\n"
"    -C\n"
"\n"
"    Only prints the list of variables that are in the COI of properties\n"
"\n"
"    -g\n"
"\n"
"    Dumps the COI model that represents the union of all COI\n"
"    properties\n"
"\n"
""},
{"show_dependencies", "COMMAND= show_dependencies   Shows the expression dependencies\n"
"\n"
"usage: show_dependencies [-h] [-k bound] -e expr\n"
" Shows the dependencies of the\n"
"given expression\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -k bound\n"
"\n"
"    Stop dependencies computation at step \"bound\"\n"
"\n"
"    -e expr\n"
"\n"
"    The expression on which the dependencies are computed on\n"
"\n"
""},
{"clean_sexp2bdd_cache", "COMMAND= clean_sexp2bdd_cache   Cleans the cache used during\n"
"evaluation of expressions to ADD and BDD representations.\n"
"\n"
"usage: clean_sexp2bdd_cache [-h] \n"
" During conversion of symbolic (node_ptr)\n"
"expressions to ADD and BDD representations the results of\n"
"evaluations are normally cached (see additionally NuSMV option\n"
"enable_sexp2bdd_caching). This allows to save time by avoid the\n"
"construction of BDD for the same expression several time. In some\n"
"situations it may be preferable to clean the cache and free collected\n"
"ADD and BDD. This operation can be done, for example, to free some\n"
"memory. Another possible reason is that dynamic reordering may\n"
"modify all existing BDDs, and cleaning the cache thereby freeing the\n"
"BDD may speed up the reordering. This command is designed\n"
"specifically to free the internal cache of evaluated expressions and\n"
"their ADDs and BDDs. Note that only the cache of exp-to-bdd evaluator\n"
"is freed. BDDs of variables, constants and expressions collected in\n"
"BDD FSM or anywhere else are not touched."},
{"print_formula", "COMMAND= print_formula   Prints a formula \n"
"usage: print_formula [-h] |\n"
"[-v] | [-f ] \n"
" In formula mode, the formula as the canonical formula is\n"
"printed. In verbose mode, the explicit assignments satisfying the\n"
"formula are printed. Prints the number of satsfying assignments for\n"
"the given formula.\n"
"\n"
"    Command Options:\n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints the list of assignments satisfying the\n"
"    formula.\n"
"\n"
"    -f\n"
"\n"
"    Prints a canonical representation of input.\n"
"\n"
""},
{"dump_expr", "COMMAND= dump_expr   Dumps a given expression (which can be\n"
"    contextualized) in the specified format. Example of supported\n"
"    format is 'dot'. \n"
"usage: dump_expr [-h] | -e -f [-o ]\n"
" Dumps an\n"
"    expression in the specified output format. Command Options:\n"
"\n"
"    -e expression\n"
"\n"
"    The required expression to be dumped.\n"
"\n"
"    -f format\n"
"\n"
"    The format to be used when dumping. Examples are dot, davinci.\n"
"\n"
"    -o filename\n"
"\n"
"    The name of the output file (default: standard output)\n"
"\n"
""},
{"set", "COMMAND= set   Sets an environment variable \n"
"usage: set [-h]\n"
"[<name>] [<value>]\n"
" A variable environment is maintained by the\n"
"command interpreter. The \"set\" command sets a variable to a\n"
"particular value, and the \"unset\" command removes the definition of a\n"
"variable. If \"set\" is given no arguments, it prints the current value\n"
"of all variables.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the command usage.\n"
"\n"
"    \n"
"\n"
"    <name>\n"
"\n"
"    Variable name\n"
"\n"
"    \n"
"\n"
"    <value>\n"
"\n"
"    Value to be assigned to the variable.\n"
"\n"
"\n"
"\n"
"Interpolation of variables is allowed when using the set command. The\n"
"variables are referred to with the prefix of '$'. So for example, what\n"
"follows can be done to check the value of a set variable:\n"
"\n"
"NuSMV> set foo bar\n"
"\n"
"NuSMV> echo $foo\n"
"\n"
"bar\n"
"\n"
"The last line \"bar\" will be the output produced by NuSMV.\n"
"\n"
"Variables can be extended by using the character ':' to concatenate\n"
"values. For example:\n"
"\n"
"NuSMV> set foo bar\n"
"\n"
"NuSMV> set foo $foo:foobar\n"
"\n"
"NuSMV> echo $foo\n"
"\n"
"bar:foobar\n"
"\n"
"The variable foo is extended with the value foobar .\n"
"\n"
"Whitespace characters may be present within quotes. However,\n"
"variable interpolation lays the restriction that the characters ':'\n"
"and '/' may not be used within quotes. This is to allow for recursive\n"
"interpolation. So for example, the following is allowed\n"
"\n"
"NuSMV> set \"foo bar\" this\n"
"\n"
"NuSMV> echo $\"foo bar\"\n"
"\n"
"this\n"
"\n"
"The last line will be the output produced by NuSMV.\n"
"\n"
"But in the following, the value of the variable foo/bar will not be\n"
"interpreted correctly:\n"
"\n"
"NuSMV> set \"foo/bar\" this\n"
"\n"
"NuSMV> echo $\"foo/bar\"\n"
"\n"
"foo/bar\n"
"\n"
"If a variable is not set by the \"set\" command, then the variable is\n"
"returned unchanged.\n"
"\n"
"Different commands use environment information for different\n"
"purposes. The command interpreter makes use of the following\n"
"parameters:\n"
"\n"
"    \n"
"\n"
"    autoexec\n"
"\n"
"    Defines a command string to be automatically executed after\n"
"    every command processed by the command interpreter. This is\n"
"    useful for things like timing commands, or tracing the progress\n"
"    of optimization.\n"
"\n"
"    \n"
"\n"
"    open_path\n"
"\n"
"    \"open_path\" (in analogy to the shell-variable PATH) is a list of\n"
"    colon-separated strings giving directories to be searched\n"
"    whenever a file is opened for read. Typically the current\n"
"    directory (.) is the first item in this list. The standard system\n"
"    library (typically $NUSMV_LIBRARY_PATH) is always implicitly\n"
"    appended to the current path. This provides a convenient\n"
"    short-hand mechanism for reaching standard library files.\n"
"\n"
"    \n"
"\n"
"    errstream\n"
"\n"
"    Standard error (normally stderr) can be re-directed to a file by\n"
"    setting the variable errstream.\n"
"\n"
"    \n"
"\n"
"    outstream\n"
"\n"
"    Standard output (normally stdout) can be re-directed to a file by\n"
"    setting the variable outstream.\n"
"\n"
""},
{"unset", "COMMAND= unset   Unsets an environment variable\n"
"\n"
"usage: unset [-h] <variables>\n"
" A variable environment is\n"
"maintained by the command interpreter. The \"set\" command sets a\n"
"variable to a particular value, and the \"unset\" command removes the\n"
"definition of a variable.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the command usage.\n"
"\n"
"    \n"
"\n"
"    <variables>\n"
"\n"
"    Variables to be unset\n"
"\n"
""},
{"check_fsm", "COMMAND= check_fsm   Checks the transition relation for totality.\n"
"\n"
"usage: check_fsm [-h] [-m | -o output-file]\n"
" Checks if the transition\n"
"relation is total. If the transition relation is not total then a\n"
"potential deadlock state is shown out.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command to the program\n"
"    specified by the PAGER shell variable if defined, else through\n"
"    the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command to the file\n"
"    output-file.\n"
"\n"
"At the beginning reachable states are computed in order to guarantee\n"
"that deadlock states are actually reachable."},
{"compute_reachable", "COMMAND= compute_reachable   Computes the set of reachable states\n"
"\n"
"usage: compute_reachable [-h] [-k number]\n"
" The set of reachable states is used\n"
"to simplify image and preimage computations. This can result in\n"
"improved performances for models with sparse state spaces.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -k number\n"
"\n"
"    Provides an explicit bound to perform at most \"number\" steps.\n"
"\n"
"    -t number\n"
"\n"
"    Provides a fail cut-off maximum CPU time to halt the computation.\n"
"    This option can be used to limit execution time.\n"
"\n"
""},
{"print_reachable_states", "COMMAND= print_reachable_states   Prints out information about\n"
"reachable states \n"
"usage: print_reachable_states [-h] [-v] [-f] [-d] [-o filename] \n"
"\n"
"Prints the number of reachable states of the given model. In verbose\n"
"mode, prints also the list of all reachable states. The reachable\n"
"states are computed if needed.\n"
"\n"
"    Command Options:\n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints the list of reachable states.\n"
"\n"
"    -f\n"
"\n"
"    Print the list of reachable states as a formula.\n"
"\n"
"    -d\n"
"\n"
"    Prints the list of reachable states with defines (Requires -v).\n"
"\n"
"    -o filename\n"
"\n"
"    Prints the result on the specified filename instead of on\n"
"    standard output\n"
"\n"
""},
{"print_fair_states", "COMMAND= print_fair_states   Prints out information about fair\n"
"states \n"
"usage: print_fair_states [-h] [-v]\n"
" This command provides information\n"
"about the fair states of the current model.number of fair states. In\n"
"verbose mode, prints also the list of fair states.\n"
"\n"
"    Command Options:\n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints the list of fair states.\n"
"\n"
""},
{"print_fair_transitions", "COMMAND= print_fair_transitions   Prints the number of fair\n"
"transitions, and list transitions in verbose mode.\n"
"\n"
"usage: print_fair_transitions [-h] [-v [-f format] [-o fname]]\n"
" Prints the number of\n"
"fair transitions. In verbose mode, prints also the list of fair\n"
"transitions.\n"
"\n"
"    Command Options:\n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints the list of fair transitions.\n"
"\n"
"    -f\n"
"\n"
"    Use given format when printing the list of fair transitions.\n"
"\n"
"    -o fname\n"
"\n"
"    Writes to given filename (default: stderr).\n"
"\n"
""},
{"dump_fsm", "COMMAND= dump_fsm   Dumps (in DOT format) selected parts of the bdd\n"
"fsm, with optional expression \n"
"usage: dump_fsm [-h] -o filename [-i]\n"
"[-I] [-t] [-f] [-r] [-e expression]\n"
" Dumps selected parts of the bdd\n"
"fsm, with optional expression, in DOT format. At least one among\n"
"options [iIte] must be specified. Command Options:\n"
"\n"
"-o filename\n"
"\n"
"Dumps to the specified file name.\n"
"\n"
"-i\n"
"\n"
"Dumps the initial states of the FSM, among with other selected\n"
"outputs.\n"
"\n"
"-I\n"
"\n"
"Dumps the invariant states of the FSM, among with other selected\n"
"outputs.\n"
"\n"
"-t\n"
"\n"
"Dumps the (monolithic) transition relation of the FSM, among with\n"
"other selected outputs.\n"
"\n"
"-F\n"
"\n"
"Dumps the (monolithic) fair states of the FSM, among with other\n"
"selected outputs.\n"
"\n"
"-r\n"
"\n"
"Dumps the (monolithic) reachable states of the FSM, among with other\n"
"selected outputs.\n"
"\n"
"-e\n"
"\n"
"Dumps the specified expression, among with other selected outputs\n"
"(see also command dump_expr).\n"
"\n"
""},
{"show_property", "COMMAND= show_property   Shows the currently stored\n"
"    properties \n"
"usage: show_property [-h] [[-c | -l | -i | -q] [-u | -t | -f]] |\n"
"    [-n property_number] | [-P property_name] | [-s] [-m | -o\n"
"    output-file] [-F format]\n"
" Shows the properties currently\n"
"    stored in the list of properties. This list is initialized with\n"
"    the properties (CTL, LTL, INVAR, COMPUTE) present in the input\n"
"    file, if any; then all of the properties added by the user with the\n"
"    relative check or add_property<\tt> commands are appended to\n"
"    this list. For every property, the following informations are\n"
"    displayed:\n"
"\n"
"    - the identifier of the property (a progressive number);\n"
"\n"
"    - the property formula;\n"
"\n"
"    - the type (CTL, LTL, INVAR, COMPUTE) the status of the formula\n"
"    (Unchecked, True, False) or the result of the quantitative\n"
"    expression, if any (it can be infinite);\n"
"\n"
"    - if the formula has been found to be false, the number of the\n"
"    corresponding counterexample trace.\n"
"\n"
"By default, all the properties currently stored in the list of\n"
"properties are shown. Specifying the suitable options, properties\n"
"with a certain status (Unchecked, True, False) and/or of a certain\n"
"type (e.g. CTL, LTL), or with a given identifier, it is possible to let\n"
"the system show a restricted set of properties. It is allowed to insert\n"
"only one option per status and one option per type.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -c\n"
"\n"
"    Prints only CTL properties.\n"
"\n"
"    -l\n"
"\n"
"    Prints only LTL properties.\n"
"\n"
"    -i\n"
"\n"
"    Prints only INVAR properties.\n"
"\n"
"    -q\n"
"\n"
"    Prints only quantitative (COMPUTE) properties.\n"
"\n"
"    -u\n"
"\n"
"    Prints only unchecked properties.\n"
"\n"
"    -t\n"
"\n"
"    Prints only those properties found to be true.\n"
"\n"
"    -f\n"
"\n"
"    Prints only those properties found to be false.\n"
"\n"
"    -n property-number\n"
"\n"
"    Prints out the property numbered property-number.\n"
"\n"
"    -P property-name\n"
"\n"
"    Prints out the property named property-name.\n"
"\n"
"    -m\n"
"\n"
"    Pipes the output through the program specified by the PAGER shell\n"
"    variable if defined, else through the UNIX \"more\" command.\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command to output-file<\tt>.\n"
"\n"
"    -F format\n"
"\n"
"    print with given format. Use -F help to see available formats.\n"
"\n"
"    -s Prints the number of stored properties.\n"
"\n"
"    <\tt>.\n"
"\n"
""},
{"add_property", "COMMAND= add_property   Adds a property to the list of properties\n"
"\n"
"usage: add_property [-h] [(-c | -l | -i | -q | -s) -p \"formula [IN context]\"]\n"
"[-n \"name\"]\n"
" Adds a property in the list of properties. It is possible\n"
"to insert LTL, CTL, INVAR, PSL and quantitative (COMPUTE)\n"
"properties. Every newly inserted property is initialized to\n"
"unchecked. A type option must be given to properly execute the\n"
"command.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -c\n"
"\n"
"    Adds a CTL property.\n"
"\n"
"    -l\n"
"\n"
"    Adds an LTL property.\n"
"\n"
"    -i\n"
"\n"
"    Adds an INVAR property.\n"
"\n"
"    -s\n"
"\n"
"    Adds a PSL property.\n"
"\n"
"    -q\n"
"\n"
"    Adds a quantitative (COMPUTE) property.\n"
"\n"
"    -p \"formula [IN context]\"\n"
"\n"
"    Adds the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -n name\n"
"\n"
"    Names the added property as \"name\"\n"
"\n"
""},
{"check_property", "COMMAND= check_property   Checks a property into the current list of\n"
"properties, or a newly specified property \n"
"usage: check_property [-h] [-n\n"
"number | -P \"name\"] | [(-c | -l | -i | -s | -q ) [-p \"formula [IN context]\"]]\n"
"\n"
" Checks the specified property taken from the property list, or adds\n"
"the new specified property and checks it.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the help.\n"
"\n"
"    -c\n"
"\n"
"    Checks all the CTL properties not already checked\n"
"\n"
"    -l\n"
"\n"
"    Checks all the LTL properties not already checked\n"
"\n"
"    -i\n"
"\n"
"    Checks all the INVAR properties not already checked\n"
"\n"
"    -s\n"
"\n"
"    Checks all the PSL properties not already checked\n"
"\n"
"    -q\n"
"\n"
"    Checks all the COMPUTE properties not already checked\n"
"\n"
"    -n number\n"
"\n"
"    Checks the property with id number in the property list if it\n"
"    exists.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the property named named in the property list if it exists.\n"
"\n"
"    -p \"formula [IN context]\"\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"If no property has been specified via -n or -p or -P, then all the\n"
"properties (of a given type) in the property list will be evaluated.\n"
""},
{"convert_property_to_invar", "COMMAND= convert_property_to_invar   \n"
"usage: convert_property_to_invar [-n number |\n"
"-P \"name\" | -p \"formula\"]\n"
""},
{"check_ltlspec", "COMMAND= check_ltlspec   Performs LTL model checking\n"
"\n"
"usage: check_ltlspec [-h] [-m | -o output-file] [-n number | -p \"ltl-expr\n"
"[IN context]\" | -P \"name\"] \n"
" Performs model checking of LTL\n"
"formulas. LTL model checking is reduced to CTL model checking as\n"
"described in the paper by [CGH97].\n"
"\n"
"A ltl-expr to be checked can be specified at command line using option\n"
"-p. Alternatively, option -n can be used for checking a particular\n"
"formula in the property database. If neither -n nor -p are used, all the\n"
"LTLSPEC formulas in the database are checked.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command in processing LTLSPECs\n"
"    to the program specified by the PAGER shell variable if defined,\n"
"    else through the Unix command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command in processing\n"
"    LTLSPECs to the file output-file.\n"
"\n"
"    -p \"ltl-expr [IN context]\"\n"
"\n"
"    An LTL formula to be checked. context is the module instance name\n"
"    which the variables in ltl_expr must be evaluated in.\n"
"\n"
"    -n number\n"
"\n"
"    Checks the LTL property with index number in the property\n"
"    database.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the LTL property named name in the property database.\n"
"\n"
""},
{"check_ctlspec", "COMMAND= check_ctlspec   Performs fair CTL model checking.\n"
"\n"
"usage: check_ctlspec [-h] [-m | -o output-file] [-n number | -p \"ctl-expr\n"
"[IN context]\" | -P \"name\"]\n"
" Performs fair CTL model checking.\n"
"\n"
"A ctl-expr to be checked can be specified at command line using option\n"
"-p. Alternatively, option -n or -P can be used for checking a\n"
"particular formula in the property database. If neither -n nor -p are\n"
"used, all the SPEC formulas in the database are checked.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command in processing SPECs to\n"
"    the program specified by the PAGER shell variable if defined,\n"
"    else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command in processing SPECs to\n"
"    the file output-file.\n"
"\n"
"    -p \"ctl-expr [IN context]\"\n"
"\n"
"    A CTL formula to be checked. context is the module instance name\n"
"    which the variables in ctl-expr must be evaluated in.\n"
"\n"
"    -n number\n"
"\n"
"    Checks the CTL property with index number in the property\n"
"    database.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the CTL property with name name in the property database.\n"
"\n"
"\n"
"\n"
"If the ag_only_search environment variable has been set, and the set\n"
"of reachable states has already been computed, then a specialized\n"
"algorithm to check AG formulas is used instead of the standard model\n"
"checking algorithms."},
{"check_invar", "COMMAND= check_invar   Performs model checking of invariants\n"
"\n"
"usage: check_invar [-h] [-m | -o output-file] [-s \"strategy\"] [-e\n"
"\"heuristic\"] [-t number] [-k number] [-j \"heuristic\"] [-n number | -p\n"
"\"invar-expr [IN context]\" | -P \"name\"]\n"
" Performs invariant checking\n"
"on the given model. An invariant is a set of states. Checking the\n"
"invariant is the process of determining that all states reachable\n"
"from the initial states lie in the invariant. Invariants to be\n"
"verified can be provided as simple formulas (without any temporal\n"
"operators) in the input file via the INVARSPEC keyword or directly at\n"
"command line, using the option -p.\n"
"\n"
"Option -n can be used for checking a particular invariant of the model.\n"
"If neither -n nor -p are used, all the invariants are checked.\n"
"\n"
"During checking of invariant all the fairness conditions associated\n"
"with the model are ignored.\n"
"\n"
"If an invariant does not hold, a proof of failure is demonstrated. This\n"
"consists of a path starting from an initial state to a state lying\n"
"outside the invariant. This path has the property that it is the\n"
"shortest path leading to a state outside the invariant.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the program in processing\n"
"    INVARSPECs to the program specified by the PAGER shell variable\n"
"    if defined, else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command in processing\n"
"    INVARSPECs to the file output-file.\n"
"\n"
"    -s strategy\n"
"\n"
"    Force the analysis strategy.\n"
"\n"
"    -e heuristic\n"
"\n"
"    Force the search heuristic for the forward-backward strategy.\n"
"\n"
"    -t number\n"
"\n"
"    When using the mixed BDD and BMC approach specify the heuristic\n"
"    threshold.\n"
"\n"
"    -k number\n"
"\n"
"    When using the mixed BDD and BMC approach specify the BMC max k.\n"
"\n"
"    -j heuristic\n"
"\n"
"    Force the switch heuristic for the BDD-BMC strategy.\n"
"\n"
"    -p \"invar-expr [IN context]\"\n"
"\n"
"    The command line specified invariant formula to be verified.\n"
"    context is the module instance name which the variables in\n"
"    invar-expr must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the INVARSPEC with name name in the property database.\n"
"\n"
""},
{"check_compute", "COMMAND= check_compute   Performs computation of quantitative\n"
"characteristics \n"
"usage: check_compute [-h] [-m | -o output-file] [-n\n"
"number | -p \"compute-expr [IN context]\" | -P \"name\"]\n"
" This command\n"
"deals with the computation of quantitative characteristics of real\n"
"time systems. It is able to compute the length of the shortest\n"
"(longest) path from two given set of states.\n"
"\n"
"MAX [ alpha , beta ]\n"
"\n"
"MIN [ alpha , beta ]\n"
"\n"
"Properties of the above form can be specified in the input file via the\n"
"keyword COMPUTE or directly at command line, using option -p.\n"
"\n"
"Option -n can be used for computing a particular expression in the\n"
"model. If neither -n nor -p nor -P are used, all the COMPUTE\n"
"specifications are computed.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command in processing COMPUTEs\n"
"    to the program specified by the PAGER shell variable if defined,\n"
"    else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command in processing\n"
"    COMPUTEs to the file output-file.\n"
"\n"
"    -p \"compute-expr [IN context]\"\n"
"\n"
"    A COMPUTE formula to be checked. context is the module instance\n"
"    name which the variables in compute-expr must be evaluated in.\n"
"\n"
"    -n number\n"
"\n"
"    Computes only the property with index number\n"
"\n"
"    -P name\n"
"\n"
"    Computes only the property named name\n"
"\n"
""},
{"compute", "COMMAND= compute   Performs computation of quantitative\n"
"characteristics \n"
"usage: compute \n"
" This command is deprecated. It has\n"
"been substituted by the command check_compute. "},
{"check_pslspec", "COMMAND= check_pslspec   Performs fair PSL model checking.\n"
"\n"
"usage: check_pslspec [-h] [-m | -o output-file] [-n number | -p \"psl-expr\n"
"[IN context]\" | -P \"name\"]\n"
" Performs fair PSL model checking.\n"
"\n"
"A psl-expr to be checked can be specified at command line using option\n"
"-p. Alternatively, option -n can be used for checking a particular\n"
"formula in the property database. If neither -n nor -p are used, all the\n"
"PSLSPEC formulas in the database are checked.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command in processing SPECs to\n"
"    the program specified by the PAGER shell variable if defined,\n"
"    else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command in processing\n"
"    PSLSPECs to the file output-file.\n"
"\n"
"    -p \"psl-expr [IN context]\"\n"
"\n"
"    A PSL formula to be checked. context is the module instance name\n"
"    which the variables in ctl-expr must be evaluated in.\n"
"\n"
"    -n number\n"
"\n"
"    Checks the PSL property with index number in the property\n"
"    database.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the PSL property named name in the property database.\n"
"\n"
"\n"
"\n"
""},
{"language_emptiness", "COMMAND= language_emptiness   Checks for language emptiness.\n"
"\n"
"usage: language_emptiness [-h] [-v] [-a]\n"
" Checks for the language emptiness.\n"
"\n"
"If -a is given the check is performed by verifying whether all initial\n"
"states are included in the set of fair states. If it is the case from all\n"
"initial states there exists a fair path and thus the language is not\n"
"empty. On the other hand, if no -a is specified, the check is performed\n"
"by verifying whether there exists at least one inital state that is\n"
"also a fair state. In this case there is an initial state from which it\n"
"starts a fair path and thus the lnaguage is not empty. if -v is\n"
"specified, then some information on the set of initial states is\n"
"printed out too."},
{"bmc_setup", "COMMAND= bmc_setup   Builds the model in a Boolean Epression format.\n"
"\n"
"usage: bmc_setup [-h] | [-f]\n"
" You must call this command before use any\n"
"other bmc-related command. Only one call per session is required.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -f\n"
"\n"
"    Forces the BMC model to be built.\n"
"\n"
""},
{"bmc_simulate", "COMMAND= bmc_simulate   Generates a trace of the model from 0 (zero)\n"
"to k \n"
"usage: bmc_simulate [-h] [-p | -v] [-r] [[-c \"constraints\"] | [-t\n"
"\"constraints\"] ] [-k steps] \n"
" bmc_simulate does not require a\n"
"specification to build the problem, because only the model is used to\n"
"build it. The problem length is represented by the -k command\n"
"parameter, or by its default value stored in the environment variable\n"
"bmc_length.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -p\n"
"\n"
"    Prints current generated trace (only those variables whose\n"
"    value changed from the previous state).\n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints current generated trace (changed and\n"
"    unchanged state variables).\n"
"\n"
"    -r\n"
"\n"
"    Picks a state from a set of possible future states in a random way.\n"
"\n"
"    -c \"constraints\"\n"
"\n"
"    Performs a simulation in which computation is restricted to\n"
"    states satisfying those constraints. The desired sequence of\n"
"    states could not exist if such constraints were too strong or it\n"
"    may happen that at some point of the simulation a future state\n"
"    satisfying those constraints doesn't exist: in that case a trace\n"
"    with a number of states less than steps trace is obtained. The\n"
"    expression cannot contain next operators, and is automatically\n"
"    shifted by one state in order to constraint only the next steps\n"
"\n"
"    -t \"constraints\"\n"
"\n"
"    Performs a simulation in which computation is restricted to\n"
"    states satisfying those constraints. The desired sequence of\n"
"    states could not exist if such constraints were too strong or it\n"
"    may happen that at some point of the simulation a future state\n"
"    satisfying those constraints doesn't exist: in that case a trace\n"
"    with a number of states less than steps trace is obtained. The\n"
"    expression can contain next operators, and is NOT automatically\n"
"    shifted by one state as done with option -c\n"
"\n"
"    -k steps\n"
"\n"
"    Maximum length of the path according to the constraints. The\n"
"    length of a trace could contain less than steps states: this is the\n"
"    case in which simulation stops in an intermediate step because it\n"
"    may not exist any future state satisfying those constraints.\n"
"\n"
""},
{"bmc_inc_simulate", "COMMAND= bmc_inc_simulate   Incrementally generates a trace of the\n"
"model performing a given number of steps. \n"
"usage: bmc_inc_simulate [-h] [-p |\n"
"-v] [-r] [[-c \"constraints\"] | [-t \"constraints\"] ] [-k steps] \n"
"\n"
"bmc_inc_simulate performs incremental simulation of the model. If\n"
"no length is specified with -k command parameter, then the number of\n"
"steps of simulation to perform is taken from the value stored in the\n"
"environment variable bmc_length.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -p\n"
"\n"
"    Prints current generated trace (only those variables whose\n"
"    value changed from the previous state).\n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints current generated trace (changed and\n"
"    unchanged state variables).\n"
"\n"
"    -r\n"
"\n"
"    Picks a state from a set of possible future states in a random way.\n"
"\n"
"    -i\n"
"\n"
"    Enters simulation's interactive mode.\n"
"\n"
"    -a\n"
"\n"
"    Displays all the state variables (changed and unchanged) in the\n"
"    interactive session\n"
"\n"
"    -c \"constraints\"\n"
"\n"
"    Performs a simulation in which computation is restricted to\n"
"    states satisfying those constraints. The desired sequence of\n"
"    states could not exist if such constraints were too strong or it\n"
"    may happen that at some point of the simulation a future state\n"
"    satisfying those constraints doesn't exist: in that case a trace\n"
"    with a number of states less than steps trace is obtained. The\n"
"    expression cannot contain next operators, and is automatically\n"
"    shifted by one state in order to constraint only the next steps\n"
"\n"
"    -t \"constraints\"\n"
"\n"
"    Performs a simulation in which computation is restricted to\n"
"    states satisfying those constraints. The desired sequence of\n"
"    states could not exist if such constraints were too strong or it\n"
"    may happen that at some point of the simulation a future state\n"
"    satisfying those constraints doesn't exist: in that case a trace\n"
"    with a number of states less than steps trace is obtained. The\n"
"    expression can contain next operators, and is NOT automatically\n"
"    shifted by one state as done with option -c\n"
"\n"
"    -k steps\n"
"\n"
"    Maximum length of the path according to the constraints. The\n"
"    length of a trace could contain less than steps states: this is the\n"
"    case in which simulation stops in an intermediate step because it\n"
"    may not exist any future state satisfying those constraints.\n"
"\n"
""},
{"bmc_pick_state", "COMMAND= bmc_pick_state   Picks a state from the set of initial\n"
"states \n"
"usage: bmc_pick_state [-h] [-v] \\n"
" Chooses an element from the set of\n"
"initial states, and makes it the current state (replacing the old\n"
"one). The chosen state is stored as the first state of a new trace ready\n"
"to be lengthened by steps states by the bmc_simulate or\n"
"bmc_inc_simulate commands. A constraint can be provided to restrict\n"
"the set of candidate states.\n"
"\n"
"Command Options:\n"
"\n"
"    \n"
"\n"
"    -v\n"
"\n"
"    Verbosely prints out chosen state (all state variables,\n"
"    otherwise it prints out only the label t.1 of the state chosen,\n"
"    where t is the number of the new trace, that is the number of traces\n"
"    so far generated plus one).\n"
"\n"
"    -r\n"
"\n"
"    Randomly picks a state from the set of initial states.\n"
"\n"
"    -i\n"
"\n"
"    Enters simulation's interactive mode.\n"
"\n"
"    -a\n"
"\n"
"    Displays all the state variables (changed and unchanged) in the\n"
"    interactive session\n"
"\n"
"    -c \"constraint\"\n"
"\n"
"    Uses constraint to restrict the set of initial states in which the\n"
"    state has to be picked.\n"
"\n"
"    -s trace.state\n"
"\n"
"    Picks state from trace.state label. A new simulation trace will\n"
"    be created by copying prefix of the source trace up to specified\n"
"    state.\n"
"\n"
""},
{"bmc_simulate_check_feasible_constraints", "COMMAND= bmc_simulate_check_feasible_constraints   Performs a\n"
"feasibility check on the list of given constraints. Constraints that\n"
"are found to be feasible can be safely assumed not to cause deadlocks if\n"
"used in the following step of incremental simulation.\n"
"\n"
"usage: bmc_simulate_check_feasible_constraints [-h | -q] [-c \"formula\"]* \n"
" This command generates\n"
"feasibility problems for each constraint. Every constraint is\n"
"checked against current state and FSM's transition relation, in\n"
"order to exclude the possibility of deadlocks. Constraints found to\n"
"be feasible can be safely assumed not to cause deadlocks if used in the\n"
"following step of incremental simulation.\n"
"\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -q\n"
"\n"
"    Enables quiet mode. For each analyzed constraint \"0\" is printed\n"
"    if the constraint is found to be unfeasible, \"1\" is printed\n"
"    otherwise.\n"
"\n"
"    \n"
"\n"
"    -c \"formula\"\n"
"\n"
"    Provide a constraint as a formula specified on the command-line.\n"
"    This option can be specified multiple times, in order to analyze a\n"
"    list of constraints.\n"
"\n"
"    \n"
"\n"
""},
{"gen_ltlspec_bmc", "COMMAND= gen_ltlspec_bmc   Dumps into one or more dimacs files the\n"
"given LTL specification, or all LTL specifications if no formula is\n"
"given. Generation and dumping parameters are the maximum bound and\n"
"the loopback values \n"
"usage: gen_ltlspec_bmc [-h | -n idx | -p \"formula\" [IN\n"
"context] | -P \"name\"] [-k max_length] [-l loopback] [-o filename]\n"
"\n"
"This command generates one or more problems, and dumps each problem\n"
"into a dimacs file. Each problem is related to a specific problem\n"
"bound, which increases from zero (0) to the given maximum problem\n"
"bound. In this short description \"length\" is the bound of the problem\n"
"that system is going to dump out.\n"
"\n"
"In this context the maximum problem bound is represented by the\n"
"max_length parameter, or by its default value stored in the\n"
"environment variable bmc_length.\n"
"\n"
"Each dumped problem also depends on the loopback you can explicitly\n"
"specify by the -l option, or by its default value stored in the\n"
"environment variable bmc_loopback.\n"
"\n"
"The property to be checked may be specified using the -n idx, the -p\n"
"\"formula\" or the -P \"name\" options.\n"
"\n"
"You may specify dimacs file name by using the option -o \"filename\",\n"
"otherwise the default value stored in the environment variable\n"
"bmc_dimacs_filename will be considered.\n"
"\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid LTL specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    The validity of index value is checked out by the system.\n"
"\n"
"    -p \"formula [IN context]\"\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the LTLSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k max_length\n"
"\n"
"    max_length is the maximum problem bound used when increasing\n"
"    problem bound starting from zero. Only natural number are valid\n"
"    values for this option. If no value is given the environment\n"
"    variable bmc_length value is considered instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, max_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    bound and loopback will be skipped during the generation and\n"
"    dumping process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to max_length. Any invalid\n"
"    combination of bound and loopback will be skipped during the\n"
"    generation process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    length-1\"\n"
"\n"
"    -o filename\n"
"\n"
"    filename is the name of dumped dimacs files, without extension.\n"
"\n"
"    If this options is not specified, variable bmc_dimacs_filename\n"
"    will be considered. The file name string may contain special\n"
"    symbols which will be macro-expanded to form the real file name.\n"
"    Possible symbols are:\n"
"\n"
"    - @F: model name with path part\n"
"\n"
"    - @f: model name without path part\n"
"\n"
"    - @k: current problem bound\n"
"\n"
"    - @l: current loopback value\n"
"\n"
"    - @n: index of the currently processed formula in the properties\n"
"    database\n"
"\n"
"    - @@: the '@' character\n"
"\n"
""},
{"gen_ltlspec_bmc_onepb", "COMMAND= gen_ltlspec_bmc_onepb   Dumps into one dimacs file the\n"
"problem generated for the given LTL specification, or for all LTL\n"
"specifications if no formula is explicitly given. Generation and\n"
"dumping parameters are the problem bound and the loopback values\n"
"\n"
"usage: gen_ltlspec_bmc_onepb [-h | -n idx | -p \"formula\" [IN context] | -P \"name\"] [-k\n"
"length] [-l loopback] [-o filename]\n"
" As the gen_ltlspec_bmc\n"
"command, but it generates and dumps only one problem given its bound\n"
"and loopback.\n"
"\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid LTL specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    The validity of index value is checked out by the system.\n"
"\n"
"    -p \"formula [IN context]\"\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the LTLSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k length\n"
"\n"
"    length is the single problem bound used to generate and dump it.\n"
"    Only natural number are valid values for this option. If no value\n"
"    is given the environment variable bmc_length is considered\n"
"    instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, length-1). Positive sign ('+') can be\n"
"    also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the generation and\n"
"    dumping process.\n"
"\n"
"    - a negative number in (-1, -length). Any invalid combination of\n"
"    length and loopback will be skipped during the generation\n"
"    process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    length-1\"\n"
"\n"
"    -o filename\n"
"\n"
"    filename is the name of the dumped dimacs file, without\n"
"    extension.\n"
"\n"
"    If this options is not specified, variable bmc_dimacs_filename\n"
"    will be considered. The file name string may contain special\n"
"    symbols which will be macro-expanded to form the real file name.\n"
"    Possible symbols are:\n"
"\n"
"    - @F: model name with path part\n"
"\n"
"    - @f: model name without path part\n"
"\n"
"    - @k: current problem bound\n"
"\n"
"    - @l: current loopback value\n"
"\n"
"    - @n: index of the currently processed formula in the properties\n"
"    database\n"
"\n"
"    - @@: the '@' character\n"
"\n"
""},
{"check_ltlspec_bmc", "COMMAND= check_ltlspec_bmc   Checks the given LTL specification,\n"
"or all LTL specifications if no formula is given. Checking parameters\n"
"are the maximum length and the loopback values \n"
"usage: check_ltlspec_bmc [-h | -n\n"
"idx | -p \"formula\" [IN context] | -P \"name\"] [-k max_length] [-l\n"
"loopback] [-o filename]\n"
" This command generates one or more\n"
"problems, and calls SAT solver for each one. Each problem is related to\n"
"a specific problem bound, which increases from zero (0) to the given\n"
"maximum problem length. Here \"length\" is the bound of the problem that\n"
"system is going to generate and/or solve.\n"
"\n"
"In this context the maximum problem bound is represented by the -k\n"
"command parameter, or by its default value stored in the environment\n"
"variable bmc_length.\n"
"\n"
"The single generated problem also depends on the \"loopback\"\n"
"parameter you can explicitly specify by the -l option, or by its\n"
"default value stored in the environment variable bmc_loopback.\n"
"\n"
"The property to be checked may be specified using the -n idx, the -p\n"
"\"formula\" or the -P \"name\" options.\n"
"\n"
"If you need to generate a dimacs dump file of all generated problems,\n"
"you must use the option -o \"filename\".\n"
"\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid LTL specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    \n"
"\n"
"    -p \"formula\" [IN context]\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the LTLSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k max_length\n"
"\n"
"    max_length is the maximum problem bound must be reached. Only\n"
"    natural number are valid values for this option. If no value is\n"
"    given the environment variable bmc_length is considered\n"
"    instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, max_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to max_length. Any invalid\n"
"    combination of length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    length-1\"\n"
"\n"
"    -o filename\n"
"\n"
"    filename is the name of the dumped dimacs file, without\n"
"    extension.\n"
"\n"
"    It may contain special symbols which will be macro-expanded to\n"
"    form the real file name. Possible symbols are:\n"
"\n"
"    - @F: model name with path part\n"
"\n"
"    - @f: model name without path part\n"
"\n"
"    - @k: current problem bound\n"
"\n"
"    - @l: current loopback value\n"
"\n"
"    - @n: index of the currently processed formula in the properties\n"
"    database\n"
"\n"
"    - @@: the '@' character\n"
"\n"
""},
{"check_ltlspec_bmc_onepb", "COMMAND= check_ltlspec_bmc_onepb   Checks the given LTL\n"
"specification, or all LTL specifications if no formula is given.\n"
"Checking parameters are the single problem bound and the loopback\n"
"values \n"
"usage: check_ltlspec_bmc_onepb [-h | -n idx | -p \"formula\" [IN context] | -P\n"
"\"name\"] [-k length] [-l loopback] [-o filename]\n"
" As command\n"
"check_ltlspec_bmc but it produces only one single problem with fixed\n"
"bound and loopback values, with no iteration of the problem bound from\n"
"zero to max_length.\n"
"\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid LTL specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    The validity of index value is checked out by the system.\n"
"\n"
"    -p \"formula [IN context]\"\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the LTLSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k length\n"
"\n"
"    length is the problem bound used when generating the single\n"
"    problem. Only natural number are valid values for this option. If\n"
"    no value is given the environment variable bmc_length is\n"
"    considered instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, max_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to length. Any invalid combination\n"
"    of length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    length-1\"\n"
"\n"
"    -o filename\n"
"\n"
"    filename is the name of the dumped dimacs file, without\n"
"    extension.\n"
"\n"
"    It may contain special symbols which will be macro-expanded to\n"
"    form the real file name. Possible symbols are:\n"
"\n"
"    - @F: model name with path part\n"
"\n"
"    - @f: model name without path part\n"
"\n"
"    - @k: current problem bound\n"
"\n"
"    - @l: current loopback value\n"
"\n"
"    - @n: index of the currently processed formula in the properties\n"
"    database\n"
"\n"
"    - @@: the '@' character\n"
"\n"
""},
{"gen_invar_bmc", "COMMAND= gen_invar_bmc   Generates the given invariant, or all\n"
"invariants if no formula is given \n"
"usage: gen_invar_bmc [-h | -n idx | -p\n"
"\"formula\" [IN context] | -P \"name\"] [-o filename]\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid INVAR specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    The validity of index value is checked out by the system.\n"
"\n"
"    -p \"formula\" [IN context]\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P \"name\"\n"
"\n"
"    Checks the invariant property stored in the properties database\n"
"    with name \"name\"\n"
"\n"
"    -o filename\n"
"\n"
"    filename is the name of the dumped dimacs file, without\n"
"    extension.\n"
"\n"
"    If you do not use this option the dimacs file name is taken from the\n"
"    environment variable bmc_invar_dimacs_filename.\n"
"\n"
"    File name may contain special symbols which will be\n"
"    macro-expanded to form the real dimacs file name. Possible\n"
"    symbols are:\n"
"\n"
"    - @F: model name with path part\n"
"\n"
"    - @f: model name without path part\n"
"\n"
"    - @n: index of the currently processed formula in the properties\n"
"    database\n"
"\n"
"    - @@: the '@' character\n"
"\n"
""},
{"check_invar_bmc", "COMMAND= check_invar_bmc   Generates and solve the given\n"
"invariant, or all invariants if no formula is given\n"
"\n"
"usage: check_invar_bmc [-h | -n idx | -p \"formula\" [IN context] | -P \"name\"] [-k\n"
"max_length] [-a algorithm] [-o filename] \n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid INVAR specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    The validity of index value is checked out by the system.\n"
"\n"
"    -p \"formula [IN context]\"\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the INVARSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k max_length\n"
"\n"
"    (Use only when selected algorithm is een-sorensson). Use to\n"
"    specify the maximal deepth to be reached by the een-sorensson\n"
"    invariant checking algorithm. If not specified, the value\n"
"    assigned to the system variable bmc_length is taken.\n"
"\n"
"    -a algorithm\n"
"\n"
"    Uses the specified algorithm to solve the invariant. If used,\n"
"    this option will override system variable bmc_invar_alg. At the\n"
"    moment, possible values are: \"classic\", \"een-sorensson\".\n"
"\n"
"    -e\n"
"\n"
"    Uses an additional step clause for algorithm \"een-sorensson\".\n"
"\n"
"    filename is the name of the dumped dimacs file, without\n"
"    extension.\n"
"\n"
"    It may contain special symbols which will be macro-expanded to\n"
"    form the real file name. Possible symbols are:\n"
"\n"
"    - @F: model name with path part\n"
"\n"
"    - @f: model name without path part\n"
"\n"
"    - @n: index of the currently processed formula in the properties\n"
"    database\n"
"\n"
"    - @@: the '@' character\n"
"\n"
""},
{"check_ltlspec_bmc_inc", "COMMAND= check_ltlspec_bmc_inc   Checks the given LTL\n"
"specification, or all LTL specifications if no formula is given,\n"
"using incremental algorithms. Checking parameters are the maximum\n"
"length and the loopback values \n"
"usage: check_ltlspec_bmc_inc [-h | -n idx | -p\n"
"\"formula\" [IN context] | -P \"name\"] [-k max_length] [-l loopback] \n"
"\n"
"This command generates one or more problems, and calls (incremental)\n"
"SAT solver for each one. Each problem is related to a specific problem\n"
"bound, which increases from zero (0) to the given maximum problem\n"
"length. Here \"length\" is the bound of the problem that system is going\n"
"to generate and/or solve.\n"
"\n"
"In this context the maximum problem bound is represented by the -k\n"
"command parameter, or by its default value stored in the environment\n"
"variable bmc_length.\n"
"\n"
"The single generated problem also depends on the \"loopback\"\n"
"parameter you can explicitly specify by the -l option, or by its\n"
"default value stored in the environment variable bmc_loopback.\n"
"\n"
"The property to be checked may be specified using the -n idx, the -p\n"
"\"formula\" or the -P \"name\" options.\n"
"\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid LTL specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    \n"
"\n"
"    -p \"formula\" [IN context]\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the LTLSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k max_length\n"
"\n"
"    max_length is the maximum problem bound must be reached. Only\n"
"    natural number are valid values for this option. If no value is\n"
"    given the environment variable bmc_length is considered\n"
"    instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, max_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to max_length. Any invalid\n"
"    combination of length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    length-1\"\n"
"\n"
""},
{"check_invar_bmc_inc", "COMMAND= check_invar_bmc_inc   Generates and solve the given\n"
"invariant, or all invariants if no formula is given\n"
"\n"
"usage: check_invar_bmc_inc [-h | -n idx | -p \"formula\" [IN context] | -P \"name\"] [-k\n"
"max_length] [-a algorithm] [-s strategy] \n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid INVAR specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    The validity of index value is checked out by the system.\n"
"\n"
"    -p \"formula [IN context]\"\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the INVARSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k max_length\n"
"\n"
"    Use to specify the maximal depth to be reached by the incremental\n"
"    invariant checking algorithm. If not specified, the value\n"
"    assigned to the system variable bmc_length is taken.\n"
"\n"
"    -a algorithm\n"
"\n"
"    Use to specify incremental invariant checking algorithm.\n"
"    Currently this can be one of the following values: dual, zigzag,\n"
"    falsification.\n"
"\n"
"    -s strategy\n"
"\n"
"    Use to specify closure strategy (this currenly applies to dual\n"
"    algorithm only). This can be one of the following values:\n"
"    backward, forward.\n"
"\n"
""},
{"check_pslspec_bmc", "COMMAND= check_pslspec_bmc   Performs fair PSL model checking.\n"
"\n"
"usage: check_pslspec_bmc [-h] [-m | -o output-file] [-n number | -p \"psl-expr\n"
"[IN context]\" | -P \"name\"] [-g] [-1] [-k bmc_length] [-l loopback]\\n"
"\n"
"Performs fair PSL model checking using BMC.\n"
"\n"
"A psl-expr to be checked can be specified at command line using option\n"
"-p. Alternatively, option -n can be used for checking a particular\n"
"formula in the property database. If neither -n nor -p are used, all the\n"
"PSLSPEC formulas in the database are checked.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command in processing SPECs to\n"
"    the program specified by the PAGER shell variable if defined,\n"
"    else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command in processing\n"
"    PSLSPECs to the file output-file.\n"
"\n"
"    -p \"psl-expr [IN context]\"\n"
"\n"
"    A PSL formula to be checked. context is the module instance name\n"
"    which the variables in ctl-expr must be evaluated in.\n"
"\n"
"    -n number\n"
"\n"
"    Checks the PSL property with index number in the property\n"
"    database.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the PSL property named name in the property database.\n"
"\n"
"    -g While solving a problem, dumps it as a DIMACS file whose name\n"
"    depends on the content of the system variable\n"
"    \"bmc_dimacs_filename\". This feature is not allowed when the\n"
"    option -i is used as well.\n"
"\n"
"    -1 Generates and solves a single problem instead of iterating\n"
"    through 0 and bmc_length.\n"
"\n"
"    -k bmc_length\n"
"\n"
"    bmc_length is the maximum problem bound must be reached if the\n"
"    option -1 is not specified. If -1 is specified, bmc_length is the\n"
"    exact length of the problem to be generated. Only natural number\n"
"    are valid values for this option. If no value is given the\n"
"    environment variable bmc_length is considered instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, bmc_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to bmc_length. Any invalid\n"
"    combination of length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    bmc_length-1\"\n"
"\n"
"\n"
"\n"
""},
{"check_pslspec_bmc_inc", "COMMAND= check_pslspec_bmc_inc   Performs fair PSL model checking\n"
"using incremental BMC. \n"
"usage: check_pslspec_bmc_inc [-h] [-m | -o output-file] [-n\n"
"number | -p \"psl-expr [IN context]\" | -P \"name\"] [-1] [-k bmc_length]\n"
"[-l loopback]\\n"
" Performs fair PSL model checking using incremental\n"
"BMC.\n"
"\n"
"A psl-expr to be checked can be specified at command line using option\n"
"-p. Alternatively, option -n can be used for checking a particular\n"
"formula in the property database. If neither -n nor -p are used, all the\n"
"PSLSPEC formulas in the database are checked.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command in processing SPECs to\n"
"    the program specified by the PAGER shell variable if defined,\n"
"    else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command in processing\n"
"    PSLSPECs to the file output-file.\n"
"\n"
"    -p \"psl-expr [IN context]\"\n"
"\n"
"    A PSL formula to be checked. context is the module instance name\n"
"    which the variables in ctl-expr must be evaluated in.\n"
"\n"
"    -n number\n"
"\n"
"    Checks the PSL property with index number in the property\n"
"    database.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the PSL property named name in the property database.\n"
"\n"
"    -1 Generates and solves a single problem instead of iterating\n"
"    through 0 and bmc_length.\n"
"\n"
"    -k bmc_length\n"
"\n"
"    bmc_length is the maximum problem bound must be reached if the\n"
"    option -1 is not specified. If -1 is specified, bmc_length is the\n"
"    exact length of the problem to be generated. Only natural number\n"
"    are valid values for this option. If no value is given the\n"
"    environment variable bmc_length is considered instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, bmc_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to bmc_length. Any invalid\n"
"    combination of length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    bmc_length-1\"\n"
"\n"
"\n"
"\n"
""},
{"check_ltlspec_sbmc", "COMMAND= check_ltlspec_sbmc   Finds error up to depth k\n"
"\n"
"usage: check_ltlspec_sbmc [-h | -n idx | -p \"formula\" [IN context] | -P \"name\"] [-k\n"
"max_length] [-l loopback] [-1] [-o filename]\n"
" This command\n"
"generates one or more problems, and calls SAT solver for each one. Each\n"
"problem is related to a specific problem bound, which increases from\n"
"zero (0) to the given maximum problem length. Here \"length\" is the\n"
"bound of the problem that system is going to generate and/or solve.\n"
"\n"
"In this context the maximum problem bound is represented by the -k\n"
"command parameter, or by its default value stored in the environment\n"
"variable bmc_length.\n"
"\n"
"The single generated problem also depends on the \"loopback\"\n"
"parameter you can explicitly specify by the -l option, or by its\n"
"default value stored in the environment variable bmc_loopback.\n"
"\n"
"The property to be checked may be specified using the -n idx or the -p\n"
"\"formula\" options.\n"
"\n"
"If you need to generate a dimacs dump file of all generated problems,\n"
"you must use the option -o \"filename\".\n"
"\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid LTL specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    \n"
"\n"
"    -p \"formula\" [IN context]\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the LTLSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k max_length\n"
"\n"
"    max_length is the maximum problem bound must be reached. Only\n"
"    natural number are valid values for this option. If no value is\n"
"    given the environment variable bmc_length is considered\n"
"    instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, max_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to max_length. Any invalid\n"
"    combination of length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    length-1\"\n"
"\n"
"    -1\n"
"\n"
"    Generates and solves a single problem with length k\n"
"\n"
"    -o filename\n"
"\n"
"    filename is the name of the dumped dimacs file. It may contain\n"
"    special symbols which will be macro-expanded to form the real\n"
"    file name. Possible symbols are:\n"
"\n"
"    - @F: model name with path part\n"
"\n"
"    - @f: model name without path part\n"
"\n"
"    - @k: current problem bound\n"
"\n"
"    - @l: current loopback value\n"
"\n"
"    - @n: index of the currently processed formula in the properties\n"
"    database\n"
"\n"
"    - @@: the '@' character\n"
"\n"
"For further information about this implementation see: T. Latvala,\n"
"A. Biere, K. Heljanko, and T. Junttila. Simple is Better: Efficient\n"
"Bounded Model Checking for Past LTL. In: R. Cousot (ed.),\n"
"Verification, Model Checking, and Abstract Interpretation, 6th\n"
"International Conference VMCAI 2005, Paris, France, Volume 3385 of\n"
"LNCS, pp. 380-395, Springer, 2005. Copyright (C) Springer-Verlag."},
{"gen_ltlspec_sbmc", "COMMAND= gen_ltlspec_sbmc   Dumps into one or more dimacs files the\n"
"given LTL specification, or all LTL specifications if no formula is\n"
"given. Generation and dumping parameters are the maximum bound and\n"
"the loopback values. Uses Kepa's and Timo's method for doing bmc.\n"
"\n"
"usage: gen_ltlspec_sbmc [-h | -n idx | -p \"formula\" [IN context] | -P \"name\"] [-k\n"
"max_length] [-l loopback] [-1] [-o filename]\n"
" This command\n"
"generates one or more problems, and dumps each problem into a dimacs\n"
"file. Each problem is related to a specific problem bound, which\n"
"increases from zero (0) to the given maximum problem bound. In this\n"
"short description \"length\" is the bound of the problem that system is\n"
"going to dump out. Uses Kepa's and Timo's method for doing bmc.\n"
"\n"
"In this context the maximum problem bound is represented by the\n"
"max_length parameter, or by its default value stored in the\n"
"environment variable bmc_length.\n"
"\n"
"Each dumped problem also depends on the loopback you can explicitly\n"
"specify by the -l option, or by its default value stored in the\n"
"environment variable bmc_loopback.\n"
"\n"
"The property to be checked may be specified using the -n idx or the -p\n"
"\"formula\" options.\n"
"\n"
"You may specify dimacs file name by using the option -o \"filename\",\n"
"otherwise the default value stored in the environment variable\n"
"bmc_dimacs_filename will be considered.\n"
"\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid LTL specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    \n"
"\n"
"    -p \"formula\" [IN context]\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the LTLSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k max_length\n"
"\n"
"    max_length is the maximum problem bound must be reached. Only\n"
"    natural number are valid values for this option. If no value is\n"
"    given the environment variable bmc_length is considered\n"
"    instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, max_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to max_length. Any invalid\n"
"    combination of length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    length-1\"\n"
"\n"
"    -1\n"
"\n"
"    Generates a single problem with length k\n"
"\n"
"    -o filename\n"
"\n"
"    filename is the name of the dumped dimacs file. It may contain\n"
"    special symbols which will be macro-expanded to form the real\n"
"    file name. Possible symbols are:\n"
"\n"
"    - @F: model name with path part\n"
"\n"
"    - @f: model name without path part\n"
"\n"
"    - @k: current problem bound\n"
"\n"
"    - @l: current loopback value\n"
"\n"
"    - @n: index of the currently processed formula in the properties\n"
"    database\n"
"\n"
"    - @@: the '@' character\n"
"\n"
"For further information about this implementation see: T. Latvala,\n"
"A. Biere, K. Heljanko, and T. Junttila. Simple is Better: Efficient\n"
"Bounded Model Checking for Past LTL. In: R. Cousot (ed.),\n"
"Verification, Model Checking, and Abstract Interpretation, 6th\n"
"International Conference VMCAI 2005, Paris, France, Volume 3385 of\n"
"LNCS, pp. 380-395, Springer, 2005. Copyright (C) Springer-Verlag."},
{"check_ltlspec_sbmc_inc", "COMMAND= check_ltlspec_sbmc_inc   Incremental SBMC LTL model\n"
"checking \n"
"usage: check_ltlspec_sbmc_inc [-h | -n idx | -p \"formula\" [IN context] | -P\n"
"\"name\"] [-k max_length] [-c] [-N]\n"
" This command generates one or more\n"
"problems, and calls SAT solver for each one. Each problem is related to\n"
"a specific problem bound, which increases from zero (0) to the given\n"
"maximum problem length. Here \"length\" is the bound of the problem that\n"
"system is going to generate and/or solve.\n"
"\n"
"In this context the maximum problem bound is represented by the -k\n"
"command parameter, or by its default value stored in the environment\n"
"variable bmc_length.\n"
"\n"
"The property to be checked may be specified using the -n idx, -p\n"
"\"formula\", or -P \"property_name\" options.\n"
"\n"
"Completeness check, although slower, can be used to determine\n"
"whether the property holds.\n"
"\n"
"\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -n index\n"
"\n"
"    index is the numeric index of a valid LTL specification formula\n"
"    actually located in the properties database.\n"
"\n"
"    \n"
"\n"
"    -p \"formula\" [IN context]\n"
"\n"
"    Checks the formula specified on the command-line.\n"
"\n"
"    context is the module instance name which the variables in\n"
"    formula must be evaluated in.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the LTLSPEC property with name name in the property\n"
"    database.\n"
"\n"
"    -k max_length\n"
"\n"
"    max_length is the maximum problem bound must be reached. Only\n"
"    natural number are valid values for this option. If no value is\n"
"    given the environment variable bmc_length is considered\n"
"    instead.\n"
"\n"
"    -c\n"
"\n"
"    Performs completeness check at every step. This can be\n"
"    effectively used to determine whether a property holds.\n"
"\n"
"    -N\n"
"\n"
"    Does not perform virtual unrolling.\n"
"\n"
"For further information about this implementation see: T. Latvala,\n"
"A. Biere, K. Heljanko, and T. Junttila. Simple is Better: Efficient\n"
"Bounded Model Checking for Past LTL. In: R. Cousot (ed.),\n"
"Verification, Model Checking, and Abstract Interpretation, 6th\n"
"International Conference VMCAI 2005, Paris, France, Volume 3385 of\n"
"LNCS, pp. 380-395, Springer, 2005. Copyright (C) Springer-Verlag."},
{"check_pslspec_sbmc", "COMMAND= check_pslspec_sbmc   Performs fair PSL model checking.\n"
"\n"
"usage: check_pslspec_sbmc [-h] [-m | -o output-file] [-n number | -p \"psl-expr\n"
"[IN context]\" | -P \"name\"] [-g] [-1] [-k bmc_length] [-l loopback]\\n"
"\n"
"Performs fair PSL model checking using SBMC.\n"
"\n"
"A psl-expr to be checked can be specified at command line using option\n"
"-p. Alternatively, option -n can be used for checking a particular\n"
"formula in the property database. If neither -n nor -p are used, all the\n"
"PSLSPEC formulas in the database are checked.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command in processing SPECs to\n"
"    the program specified by the PAGER shell variable if defined,\n"
"    else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command in processing\n"
"    PSLSPECs to the file output-file.\n"
"\n"
"    -p \"psl-expr [IN context]\"\n"
"\n"
"    A PSL formula to be checked. context is the module instance name\n"
"    which the variables in ctl-expr must be evaluated in.\n"
"\n"
"    -n number\n"
"\n"
"    Checks the PSL property with index number in the property\n"
"    database.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the PSL property named name in the property database.\n"
"\n"
"    -g While solving a problem, dumps it as a DIMACS file whose name\n"
"    depends on the content of the system variable\n"
"    \"bmc_dimacs_filename\". This feature is not allowed when the\n"
"    option -i is used as well.\n"
"\n"
"    -1 Generates and solves a single problem instead of iterating\n"
"    through 0 and bmc_length.\n"
"\n"
"    -k bmc_length\n"
"\n"
"    bmc_length is the maximum problem bound must be reached if the\n"
"    option -1 is not specified. If -1 is specified, bmc_length is the\n"
"    exact length of the problem to be generated. Only natural number\n"
"    are valid values for this option. If no value is given the\n"
"    environment variable bmc_length is considered instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, bmc_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to bmc_length. Any invalid\n"
"    combination of length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    bmc_length-1\"\n"
"\n"
"\n"
"\n"
""},
{"check_pslspec_sbmc_inc", "COMMAND= check_pslspec_sbmc_inc   Performs fair PSL model\n"
"checking. \n"
"usage: check_pslspec_sbmc_inc [-h] [-m | -o output-file] [-n number | -p\n"
"\"psl-expr [IN context]\" | -P \"name\"] [-1] [-k bmc_length] [-l\n"
"loopback]\\n"
" Performs fair PSL model checking using SBMC.\n"
"\n"
"A psl-expr to be checked can be specified at command line using option\n"
"-p. Alternatively, option -n can be used for checking a particular\n"
"formula in the property database. If neither -n nor -p are used, all the\n"
"PSLSPEC formulas in the database are checked.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -m\n"
"\n"
"    Pipes the output generated by the command in processing SPECs to\n"
"    the program specified by the PAGER shell variable if defined,\n"
"    else through the UNIX command \"more\".\n"
"\n"
"    -o output-file\n"
"\n"
"    Writes the output generated by the command in processing\n"
"    PSLSPECs to the file output-file.\n"
"\n"
"    -p \"psl-expr [IN context]\"\n"
"\n"
"    A PSL formula to be checked. context is the module instance name\n"
"    which the variables in ctl-expr must be evaluated in.\n"
"\n"
"    -n number\n"
"\n"
"    Checks the PSL property with index number in the property\n"
"    database.\n"
"\n"
"    -P name\n"
"\n"
"    Checks the PSL property named name in the property database.\n"
"\n"
"    -1 Generates and solves a single problem instead of iterating\n"
"    through 0 and bmc_length.\n"
"\n"
"    -k bmc_length\n"
"\n"
"    bmc_length is the maximum problem bound must be reached if the\n"
"    option -1 is not specified. If -1 is specified, bmc_length is the\n"
"    exact length of the problem to be generated. Only natural number\n"
"    are valid values for this option. If no value is given the\n"
"    environment variable bmc_length is considered instead.\n"
"\n"
"    -l loopback\n"
"\n"
"    loopback value may be:\n"
"\n"
"    - a natural number in (0, bmc_length-1). Positive sign ('+') can\n"
"    be also used as prefix of the number. Any invalid combination of\n"
"    length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - a negative number in (-1, -bmc_length). In this case loopback is\n"
"    considered a value relative to bmc_length. Any invalid\n"
"    combination of length and loopback will be skipped during the\n"
"    generation/solving process.\n"
"\n"
"    - the symbol 'X', which means \"no loopback\"\n"
"\n"
"    - the symbol '*', which means \"all possible loopback from zero to\n"
"    bmc_length-1\"\n"
"\n"
"\n"
"\n"
""},
{"dynamic_var_ordering", "COMMAND= dynamic_var_ordering   Deals with the dynamic variable\n"
"ordering. \n"
"usage: dynamic_var_ordering [-d] [-e <method>] [-f <method>] [-h]\n"
"\n"
"Controls the application and the modalities of (dynamic) variable\n"
"ordering. Dynamic ordering is a technique to reorder the BDD\n"
"variables to reduce the size of the existing BDDs. When no options are\n"
"specified, the current status of dynamic ordering is displayed. At\n"
"most one of the options -e, -f, and -d should be specified.\n"
"\n"
"Dynamic ordering may be time consuming, but can often reduce the size\n"
"of the BDDs dramatically. A good point to invoke dynamic ordering\n"
"explicitly (using the -f option) is after the commands build_model,\n"
"once the transition relation has been built. It is possible to save the\n"
"ordering found using write_order in order to reuse it (using\n"
"build_model -i order-file) in the future.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -d\n"
"\n"
"    Disable dynamic ordering from triggering automatically.\n"
"\n"
"    -e <method>\n"
"\n"
"        Enable dynamic ordering to trigger automatically whenever\n"
"        a certain threshold on the overall BDD size is reached.\n"
"        <method> must be one of the following:\n"
"\n"
"        - sift: Moves each variable throughout the order to find an\n"
"        optimal position for that variable (assuming all other\n"
"        variables are fixed). This generally achieves greater size\n"
"        reductions than the window method, but is slower.\n"
"\n"
"        - random: Pairs of variables are randomly chosen, and\n"
"        swapped in the order. The swap is performed by a series of\n"
"        swaps of adjacent variables. The best order among those\n"
"        obtained by the series of swaps is retained. The number of\n"
"        pairs chosen for swapping equals the number of variables in\n"
"        the diagram.\n"
"\n"
"        - random_pivot: Same as random, but the two variables are\n"
"        chosen so that the first is above the variable with the\n"
"        largest number of nodes, and the second is below that\n"
"        variable. In case there are several variables tied for the\n"
"        maximum number of nodes, the one closest to the root is used.\n"
"\n"
"        - sift_converge: The sift method is iterated until no\n"
"        further improvement is obtained.\n"
"\n"
"        - symmetry_sift: This method is an implementation of\n"
"        symmetric sifting. It is similar to sifting, with one\n"
"        addition: Variables that become adjacent during sifting\n"
"        are tested for symmetry. If they are symmetric, they are\n"
"        linked in a group. Sifting then continues with a group being\n"
"        moved, instead of a single variable.\n"
"\n"
"        - symmetry_sift_converge: The symmetry_sift method is\n"
"        iterated until no further improvement is obtained.\n"
"\n"
"        - window{2,3,4}: Permutes the variables within windows of\n"
"        \"n\" adjacent variables, where \"n\" can be either 2, 3 or 4, so as\n"
"        to minimize the overall BDD size.\n"
"\n"
"        \n"
"\n"
"        - window{2,3,4}_converge: The window{2,3,4} method is\n"
"        iterated until no further improvement is obtained.\n"
"\n"
"        - group_sift: This method is similar to symmetry_sift, but\n"
"        uses more general criteria to create groups.\n"
"\n"
"        - group_sift_converge: The group_sift method is iterated\n"
"        until no further improvement is obtained.\n"
"\n"
"        - annealing: This method is an implementation of simulated\n"
"        annealing for variable ordering. This method is\n"
"        potentially very slow.\n"
"\n"
"        - genetic: This method is an implementation of a genetic\n"
"        algorithm for variable ordering. This method is\n"
"        potentially very slow.\n"
"\n"
"        - exact: This method implements a dynamic programming\n"
"        approach to exact reordering. It only stores a BDD at a time.\n"
"        Therefore, it is relatively efficient in terms of memory.\n"
"        Compared to other reordering strategies, it is very slow,\n"
"        and is not recommended for more than 16 boolean variables.\n"
"\n"
"        - linear: This method is a combination of sifting and linear\n"
"        transformations.\n"
"\n"
"        - linear_converge: The linear method is iterated until no\n"
"        further improvement is obtained.\n"
"\n"
"    \n"
"\n"
"    \n"
"\n"
"    -f <method>\n"
"\n"
"    Force dynamic ordering to be invoked immediately. The values for\n"
"    <method> are the same as in option -e.\n"
"\n"
""},
{"set_bdd_parameters", "COMMAND= set_bdd_parameters   Creates a table with the value of all\n"
"currently active NuSMV flags and change accordingly the\n"
"configurable parameters of the BDD package. \n"
"usage: set_bdd_parameters [-h]\n"
"[-s]\n"
" Applies the variables table of the NuSMV environnement to the\n"
"BDD package, so the user can set specific BDD parameters to the given\n"
"value. This command works in conjunction with the print_bdd_stats\n"
"and set commands.\n"
"\n"
"print_bdd_stats first prints a report of the parameters and\n"
"statistics of the current bdd_manager. By using the command set, the\n"
"user may modify the value of any of the parameters of the underlying BDD\n"
"package. The way to do it is by setting a value in the variable\n"
"BDD.parameter name where parameter name is the name of the parameter\n"
"exactly as printed by the print_bdd_stats command.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -s\n"
"\n"
"    Prints the BDD parameter and statistics after the modification.\n"
"\n"
""},
{"print_bdd_stats", "COMMAND= print_bdd_stats   Prints out the BDD statistics and\n"
"parameters \n"
"usage: print_bdd_stats [-h]\n"
" Prints the statistics for the BDD\n"
"package. The amount of information depends on the BDD package\n"
"configuration established at compilation time. The configurtion\n"
"parameters are printed out too. More information about statistics\n"
"and parameters can be found in the documentation of the CUDD Decision\n"
"Diagram package."},
{"reset", "COMMAND= reset   Resets the whole system. \n"
"usage: reset [-h]\n"
"\n"
"Resets the whole system, in order to read in another model and to\n"
"perform verification on it.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the command usage.\n"
"\n"
""},
{"print_usage", "COMMAND= print_usage   Prints processor and BDD statistics.\n"
"\n"
"usage: print_usage [-h]\n"
" Prints a formatted dump of processor-specific\n"
"usage statistics, and BDD usage statistics. For Berkeley Unix, this\n"
"includes all of the information in the getrusage() structure.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -h\n"
"\n"
"    Prints the command usage.\n"
"\n"
""},
{"time", "COMMAND= time   Provides a simple CPU elapsed time value\n"
"\n"
"usage: time [-h]\n"
" Prints the processor time used since the last\n"
"invocation of the \"time\" command, and the total processor time used\n"
"since NuSMV was started."},
{"echo", "COMMAND= echo   Merely echoes the arguments. File redirection is\n"
"allowed. \n"
"usage: echo [-h] [-2] [-n] [-o filename [-a]] <args>\n"
"\n"
"Echoes its arguments to standard output.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -2\n"
"\n"
"    Redirects output to the standard error instead of the standard\n"
"    output. This cannot be used in combination with -o.\n"
"\n"
"    -n\n"
"\n"
"    Does not output the trailing newline.\n"
"\n"
"    -o filename\n"
"\n"
"    Echoes on the specified file instead of on the standard output.\n"
"\n"
"    -a\n"
"\n"
"    When used with option -o, appends the output to the specified file\n"
"    instead of overwriting it.\n"
"\n"
""},
{"_memory_profile", "COMMAND= _memory_profile   It shows the amount of memory used by\n"
"every package. \n"
"usage: _memory_profile [-f <filename>] [-h] [-p] [-u\n"
"<units>]\n"
" This command intregrates the output from purify with a\n"
"function map generated by a perlscript plus another perlscript to\n"
"generate a memory profile of NuSMV.\n"
"\n"
"This command relies on the output of purify to a file to call the script\n"
"\"memoryaccount\" and produces a summary of how much memory has been\n"
"allocated by each package. Although this command may appear simple it\n"
"requires the interaction of two scripts and three files, so special\n"
"care should be taken when attempting to modify it.\n"
"\n"
"Here is the way it works. The code in this command is conditionally\n"
"compiled depending on the definition of the symbol PURIFY. If the\n"
"symbol is not defined, the program prints a message notifying that the\n"
"command is not operative in this executable. If PURIFY has been\n"
"defined, there are certain things that are assumed. The executable\n"
"has been linked with purify. The output of purify is being redirected\n"
"to a file with name purify.log. The perl script memoryaccount is in\n"
"$NUSMV_LIBRARY_PATH/common/share and it is executable. There\n"
"exists a file whose name is .fmap, located in the same directory which\n"
"script memoryaccount is located in. This file maps function names to\n"
"packages which contain them.\n"
"\n"
"The command then calls purify_all_inuse() to force purify to dump to\n"
"the file purify.log all information about the memory that is\n"
"currently visible to the program. This memory is not the total memory\n"
"allocated by the program since there may be leaked memory that is no\n"
"longer accessible. A temporary file is created and the script\n"
"memoryaccount is called to analyze the file purify.log and write in\n"
"the temporary file the memory profile obtained from it. Once the\n"
"script is done, the temporary file is dumped to outstream and deleted.\n"
"\n"
"Since most of the computation in this command is done by the\n"
"pearlscript memoryaccount, for more information please refer to the\n"
"message printed when the script is invoked with the option -h. Command\n"
"options:\n"
"\n"
"    \n"
"\n"
"    -f <filename>\n"
"\n"
"    File to read the dump from. The default is purify.log. This option\n"
"    should be used if and only if the option -log-file has been used at\n"
"    the linking stage when building the executable.\n"
"\n"
"    -p\n"
"\n"
"    Prints also the packages that did not allocated any detectable\n"
"    memory\n"
"\n"
"    -u <units>\n"
"\n"
"    Units to print the memory usage in. It may be \"b\" for bytes, \"k\" for\n"
"    kilobytes, \"m\" for megabytes and \"g\" for gigabytes. The default\n"
"    is bytes.\n"
"\n"
""},
{"quit", "COMMAND= quit   exits NuSMV \n"
"usage: quit [-h] [-s] [-x]\n"
" Stops the\n"
"program. Does not save the current network before exiting.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -s\n"
"\n"
"    Frees all the used memory before quitting. This is slower, and it\n"
"    is used for finding memory leaks.\n"
"\n"
"    -x\n"
"\n"
"    Leave immediately. Skip all the cleanup code, leave it to the OS.\n"
"    This can save quite a long time.\n"
"\n"
""},
{"usage", "COMMAND= usage   Provides a dump of process statistics\n"
"\n"
"usage: usage [-h]\n"
" Prints a formatted dump of processor-specific\n"
"usage statistics. For Berkeley Unix, this includes all of the\n"
"information in the getrusage() structure."},
{"which", "COMMAND= which   Looks for a file called \"file_name\"\n"
"\n"
"usage: which [-h] <file_name>\n"
" Looks for a file in a set of\n"
"directories which includes the current directory as well as those in\n"
"the NuSMV path. If it finds the specified file, it reports the found\n"
"file's path. The searching path is specified through the \"set\n"
"open_path\" command in \".nusmvrc\".\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    <file_name>\n"
"\n"
"    File to be searched\n"
"\n"
""},
{"history", "COMMAND= history   list previous commands and their event numbers\n"
"\n"
"usage: history [-h] [<num>]\n"
" Lists previous commands and their\n"
"event numbers. This is a UNIX-like history mechanism inside the NuSMV\n"
"shell.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    <num>\n"
"\n"
"    Lists the last <num> events. Lists the last 30 events if <num> is\n"
"    not specified.\n"
"\n"
"\n"
"\n"
"History Substitution:\n"
"\n"
"The history substitution mechanism is a simpler version of the csh\n"
"history substitution mechanism. It enables you to reuse words from\n"
"previously typed commands.\n"
"\n"
"The default history substitution character is the `%' (`!' is default\n"
"for shell escapes, and `#' marks the beginning of a comment). This can\n"
"be changed using the \"set\" command. In this description '%' is used as\n"
"the history_char. The `%' can appear anywhere in a line. A line\n"
"containing a history substitution is echoed to the screen after the\n"
"substitution takes place. `%' can be preceded by a `\\' in order to\n"
"escape the substitution, for example, to enter a `%' into an alias or to\n"
"set the prompt.\n"
"\n"
"\n"
"\n"
"Each valid line typed at the prompt is saved. If the \"history\" variable\n"
"is set (see help page for \"set\"), each line is also echoed to the history\n"
"file. You can use the \"history\" command to list the previously typed\n"
"commands.\n"
"\n"
"Substitutions:\n"
"\n"
"At any point in a line these history substitutions are available.\n"
"\n"
"    \n"
"\n"
"    %:0\n"
"\n"
"    Initial word of last command.\n"
"\n"
"    \n"
"\n"
"    %:n\n"
"\n"
"    n-th argument of last command.\n"
"\n"
"    \n"
"\n"
"    %$\n"
"\n"
"    Last argument of last command.\n"
"\n"
"    \n"
"\n"
"    %*\n"
"\n"
"    All but initial word of last command.\n"
"\n"
"    \n"
"\n"
"    %%\n"
"\n"
"    Last command.\n"
"\n"
"    \n"
"\n"
"    %stuf\n"
"\n"
"    Last command beginning with \"stuf\".\n"
"\n"
"    \n"
"\n"
"    %n\n"
"\n"
"    Repeat the n-th command.\n"
"\n"
"    \n"
"\n"
"    %-n\n"
"\n"
"    Repeat the n-th previous command.\n"
"\n"
"    \n"
"\n"
"    ^old^new\n"
"\n"
"    Replace \"old\" with \"new\" in previous command. Trailing spaces\n"
"    are significant during substitution. Initial spaces are not\n"
"    significant.\n"
"\n"
""},
{"alias", "COMMAND= alias   Provides an alias for a command \n"
"usage: alias [-h]\n"
"[<name> [<string>]]\n"
" The \"alias\" command, if given no arguments,\n"
"will print the definition of all current aliases.\n"
"\n"
"Given a single argument, it will print the definition of that alias (if\n"
"any). Given two arguments, the keyword <name> becomes an alias for the\n"
"command string <string>, replacing any other alias with the same\n"
"name.\n"
"\n"
"    Command options:\n"
"\n"
"    <name>\n"
"\n"
"    Alias\n"
"\n"
"    <string>\n"
"\n"
"    Command string\n"
"\n"
"It is possible to create aliases that take arguments by using the\n"
"history substitution mechanism. To protect the history\n"
"substitution character `%' from immediate expansion, it must be\n"
"preceded by a `\\' when entering the alias.\n"
"\n"
"For example:\n"
"\n"
"NuSMV> alias read \"read_model -i \\%:1.smv ; set input_order_file\n"
"\\%:1.ord\" NuSMV> read short\n"
"\n"
"will create an alias `read', execute \"read_model -i short.smv; set\n"
"input_order_file short.ord\".\n"
"\n"
"And again:\n"
"\n"
"NuSMV> alias echo2 \"echo Hi ; echo \\%* !\"\n"
"\n"
"NuSMV> echo2 happy birthday\n"
"\n"
"will print:\n"
"\n"
"Hi\n"
"\n"
"happy birthday !\n"
"\n"
"CAVEAT: Currently there is no check to see if there is a circular\n"
"dependency in the alias definition. e.g.\n"
"\n"
"NuSMV> alias foo \"echo print_bdd_stats; foo\"\n"
"\n"
"creates an alias which refers to itself. Executing the command foo\n"
"will result an infinite loop during which the command\n"
"print_bdd_stats will be executed. "},
{"unalias", "COMMAND= unalias   Removes the definition of an alias.\n"
"\n"
"usage: unalias [-h] <alias-names>\n"
" Removes the definition of an\n"
"alias specified via the alias command.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    <alias-names>\n"
"\n"
"    Aliases to be removed\n"
"\n"
""},
{"help", "COMMAND= help   Provides on-line information on commands\n"
"\n"
"usage: help [-h] [-a] [-p] [<command>]\n"
" If invoked with no\n"
"arguments \"help\" prints the list of all commands known to the command\n"
"interpreter. If a command name is given, detailed information for\n"
"that command will be provided.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -a\n"
"\n"
"    Provides a list of all internal commands, whose names begin with\n"
"    the underscore character ('_') by convention.\n"
"\n"
"    -p\n"
"\n"
"    Disables the use of a pager like 'more' or any set in environment\n"
"    variable 'PAGER'.\n"
"\n"
""},
{"source", "COMMAND= source   Executes a sequence of commands from a file\n"
"\n"
"usage: source [-h] [-p] [-s] [-x] <file> [<args>]\n"
" Reads and\n"
"executes commands from a file.\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -p\n"
"\n"
"    Prints a prompt before reading each command.\n"
"\n"
"    -s\n"
"\n"
"    Silently ignores an attempt to execute commands from a\n"
"    nonexistent file.\n"
"\n"
"    -x\n"
"\n"
"    Echoes each command before it is executed.\n"
"\n"
"    <file>\n"
"\n"
"    File name\n"
"\n"
"Arguments on the command line after the filename are remembered but\n"
"not evaluated. Commands in the script file can then refer to these\n"
"arguments using the history substitution mechanism.\n"
"\n"
"EXAMPLE:\n"
"\n"
"Contents of test.scr:\n"
"\n"
"\n"
"\n"
"read_model -i %:2\n"
"\n"
"flatten_hierarchy\n"
"\n"
"build_variables\n"
"\n"
"build_model\n"
"\n"
"\n"
"\n"
"Typing \"source test.scr short.smv\" on the command line will execute\n"
"the sequence\n"
"\n"
"\n"
"\n"
"read_model -i short.smv\n"
"\n"
"flatten_hierarchy\n"
"\n"
"build_variables\n"
"\n"
"build_model\n"
"\n"
"\n"
"\n"
"(In this case %:0 gets \"source\", %:1 gets \"test.scr\", and %:2 gets\n"
"\"short.smv\".) If you type \"alias st source test.scr\" and then type \"st\n"
"short.smv bozo\", you will execute\n"
"\n"
"\n"
"\n"
"read_model -i bozo\n"
"\n"
"flatten_hierarchy\n"
"\n"
"build_variables\n"
"\n"
"build_model\n"
"\n"
"\n"
"\n"
"because \"bozo\" was the second argument on the last command line typed.\n"
"In other words, command substitution in a script file depends on how\n"
"the script file was invoked. Switches passed to a command are also\n"
"counted as positional parameters. Therefore, if you type \"st -x\n"
"short.smv bozo\", you will execute\n"
"\n"
"read_model -i short.smv\n"
"\n"
"flatten_hierarchy\n"
"\n"
"build_variables\n"
"\n"
"build_model\n"
"\n"
"\n"
"\n"
"To pass the \"-x\" switch (or any other switch) to \"source\" when the\n"
"script uses positional parameters, you may define an alias. For\n"
"instance, \"alias srcx source -x\".\n"
"\n"
"returns -3 if an error occurs and the flag 'on_failure_script_quits'\n"
"is set. "},
{"_show_help", "COMMAND= _show_help   Provides on-line information for all\n"
"commands \n"
"usage: _show_help [-f] [-h] [<command>]\n"
" If invoked with no\n"
"arguments prints the short help for all commands known to the command\n"
"interpreter including hidden commands (those whose name starts with\n"
"_).\n"
"\n"
"Command options:\n"
"\n"
"    \n"
"\n"
"    -f\n"
"\n"
"\n"
"\n"
"Prints for each command the long help.\n"
"\n"
"\n"
"\n"
""}

};

/* this is computed by scripts/create_help.py -n */
int command_number=90
;


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/* functions helpful to manipulate the dynamic map */
void cmd_help_init(NuSMVEnv_ptr env)
{
  int i;
  hash_ptr help;
  if (!NuSMVEnv_has_value(env, ENV_CMD_HELP)) {
      NuSMVEnv_set_value(env, ENV_CMD_HELP, new_assoc_string_key());
  }

  help = NuSMVEnv_get_value(env, ENV_CMD_HELP);

  for (i=0; i<command_number; i++) {
    insert_assoc(help,
                 NODE_PTR(command_help[i].command_name),
                 NODE_PTR(command_help[i].command_description));
  }
}


void cmd_help_quit(NuSMVEnv_ptr env)
{
  hash_ptr help = (hash_ptr)NuSMVEnv_remove_value(env, ENV_CMD_HELP);
  free_assoc(help);
}


char* cmd_help_get(NuSMVEnv_ptr env, char* command_name)
{
  hash_ptr help = NuSMVEnv_get_value(env, ENV_CMD_HELP);
  char* command_description = (char*)find_assoc(help,NODE_PTR(command_name));
  return command_description;
}


void cmd_help_add(NuSMVEnv_ptr env,
                  const char* command_name,
                  const char* command_description)
{
  hash_ptr help = NuSMVEnv_get_value(env, ENV_CMD_HELP);
  insert_assoc(help, NODE_PTR(command_name), NODE_PTR(command_description));
}


void cmd_help_remove(NuSMVEnv_ptr env, char* command_name)
{
  hash_ptr help = NuSMVEnv_get_value(env, ENV_CMD_HELP);
  node_ptr command_removed = remove_assoc(help, NODE_PTR(command_name));
}
